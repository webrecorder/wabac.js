/*! wombat.js (wabac.js 2.16.13) is part of Webrecorder project. Copyright (C) 2020-2024, Webrecorder Software. Licensed under the Affero General Public License v3. */(()=>{"use strict";var __webpack_modules__={"../wombat/src/autoFetcher.js":
/*!************************************!*\
  !*** ../wombat/src/autoFetcher.js ***!
  \************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AutoFetcher)\n/* harmony export */ });\n/* harmony import */ var _wombatUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wombatUtils */ \"../wombat/src/wombatUtils.js\");\n/* eslint-disable camelcase */\n\n\n/**\n * Create a new instance of AutoFetcher\n * @param {Wombat} wombat\n * @param {{isTop: boolean, workerURL: string}} config\n */\nfunction AutoFetcher(wombat, config) {\n  if (!(this instanceof AutoFetcher)) {\n    return new AutoFetcher(wombat, config);\n  }\n  // specifically target the elements we desire\n  this.elemSelector =\n    'img[srcset], img[data-srcset], img[data-src], video[srcset], video[data-srcset], video[data-src], audio[srcset], audio[data-srcset], audio[data-src], ' +\n    'picture > source[srcset], picture > source[data-srcset], picture > source[data-src], ' +\n    'video > source[srcset], video > source[data-srcset], video > source[data-src], ' +\n    'audio > source[srcset], audio > source[data-srcset], audio > source[data-src]';\n\n  /** @type {Wombat} */\n  this.wombat = wombat;\n  /** @type {Window} */\n  this.$wbwindow = wombat.$wbwindow;\n\n  /** @type {?Worker|Object} */\n  this.worker = null;\n  (0,_wombatUtils__WEBPACK_IMPORTED_MODULE_0__.autobind)(this);\n  this._initWorker(config);\n}\n\n/**\n * Initializes the backing worker IFF the execution context we are in is\n * the replay tops otherwise creates a dummy worker that simply bounces the\n * message that would have been sent to the backing worker to replay top.\n *\n * If creation of the worker fails, likely due to the execution context we\n * are currently in having an null origin, we fallback to dummy worker creation.\n * @param {{isTop: boolean, workerURL: string}} config\n * @private\n */\nAutoFetcher.prototype._initWorker = function(config) {\n  var wombat = this.wombat;\n  if (config.isTop) {\n    // we are top and can will own this worker\n    // setup URL for the kewl case\n    // Normal replay and preservation mode pworker setup, its all one origin so YAY!\n    try {\n      this.worker = new Worker(config.workerURL, {\n        type: 'classic',\n        credentials: 'include'\n      });\n    } catch (e) {\n      // it is likely we are in some kind of horrid iframe setup\n      // and the execution context we are currently in has a null origin\n      console.error('Failed to create auto fetch worker\\n', e);\n    }\n    return;\n  }\n\n  // add only the portions of the worker interface we use since we are not top\n  // and if in proxy mode start check polling\n  this.worker = {\n    postMessage: function(msg) {\n      if (!msg.wb_type) {\n        msg = { wb_type: 'aaworker', msg: msg };\n      }\n      wombat.$wbwindow.__WB_replay_top.__orig_postMessage(msg, '*');\n    },\n    terminate: function() {}\n  };\n};\n\n/**\n * Extracts the media rules from the supplied CSSStyleSheet object if any\n * are present and returns an array of the media cssText\n * @param {CSSStyleSheet} sheet\n * @return {Array<string>}\n */\nAutoFetcher.prototype.extractMediaRulesFromSheet = function(sheet) {\n  var rules;\n  var media = [];\n  try {\n    rules = sheet.cssRules || sheet.rules;\n  } catch (e) {\n    return media;\n  }\n\n  // loop through each rule of the stylesheet\n  for (var i = 0; i < rules.length; ++i) {\n    var rule = rules[i];\n    if (rule.type === CSSRule.MEDIA_RULE) {\n      // we are a media rule so get its text\n      media.push(rule.cssText);\n    }\n  }\n  return media;\n};\n\n/**\n * Extracts the media rules from the supplied CSSStyleSheet object if any\n * are present after a tick of the event loop sending the results of the\n * extraction to the backing worker\n * @param {CSSStyleSheet|StyleSheet} sheet\n */\nAutoFetcher.prototype.deferredSheetExtraction = function(sheet) {\n  var afw = this;\n  // defer things until next time the Promise.resolve Qs are cleared\n  Promise.resolve().then(function() {\n    // loop through each rule of the stylesheet\n    var media = afw.extractMediaRulesFromSheet(sheet);\n    if (media.length > 0) {\n      // we have some media rules to preserve\n      afw.preserveMedia(media);\n    }\n  });\n};\n\n/**\n * Terminates the backing worker. This is a no op when we are not\n * operating in the execution context of replay top\n */\nAutoFetcher.prototype.terminate = function() {\n  // terminate the worker, a no op when not replay top\n  this.worker.terminate();\n};\n\n/**\n * Sends the supplied array of URLs to the backing worker\n * @param {Array<string>} urls\n */\nAutoFetcher.prototype.justFetch = function(urls) {\n  this.worker.postMessage({ type: 'fetch-all', values: urls });\n};\n\n/**\n * Sends the supplied url with extra options to indicate\n * that this is a page to backing worker\n * @param {string} url\n * @param {string} originalUrl\n * @param {string} [title]\n */\nAutoFetcher.prototype.fetchAsPage = function(url, originalUrl, title) {\n  if (!url) {\n    return;\n  }\n\n  var headers = { 'X-Wombat-History-Page': originalUrl };\n  if (title) {\n    var encodedTitle = encodeURIComponent(title.trim());\n    if (title) {\n      headers['X-Wombat-History-Title'] = encodedTitle;\n    }\n  }\n\n  var fetchData = {\n    url: url,\n    options: { headers: headers, cache: 'no-store' }\n  };\n\n  this.justFetch([fetchData]);\n};\n\n/**\n * Sends a message to backing worker. If deferred is true\n * the message is sent after one tick of the event loop\n * @param {Object} msg\n * @param {boolean} [deferred]\n */\nAutoFetcher.prototype.postMessage = function(msg, deferred) {\n  if (deferred) {\n    var afWorker = this;\n    Promise.resolve().then(function() {\n      afWorker.worker.postMessage(msg);\n    });\n    return;\n  }\n  this.worker.postMessage(msg);\n};\n\n/**\n * Sends the supplied srcset value to the backing worker for preservation\n * @param {string|Array<string>} srcset\n * @param {string} [mod]\n */\nAutoFetcher.prototype.preserveSrcset = function(srcset, mod) {\n  // send values from rewriteSrcset to the worker\n  this.postMessage(\n    {\n      type: 'values',\n      srcset: { value: srcset, mod: mod, presplit: true }\n    },\n    true\n  );\n};\n\n/**\n * Send the value of the supplied elements data-srcset attribute to the\n * backing worker for preservation\n * @param {Node} elem\n */\nAutoFetcher.prototype.preserveDataSrcset = function(elem) {\n  // send values from rewriteAttr srcset to the worker deferred\n  // to ensure the page viewer sees the images first\n  this.postMessage(\n    {\n      type: 'values',\n      srcset: {\n        value: elem.dataset.srcset,\n        mod: this.rwMod(elem),\n        presplit: false\n      }\n    },\n    true\n  );\n};\n\n/**\n * Sends the supplied array of cssText from media rules to the backing worker\n * @param {Array<string>} media\n */\nAutoFetcher.prototype.preserveMedia = function(media) {\n  // send CSSMediaRule values to the worker\n  this.postMessage({ type: 'values', media: media }, true);\n};\n\n/**\n * Extracts the value of the srcset property if it exists from the supplied\n * element\n * @param {Element} elem\n * @return {?string}\n */\nAutoFetcher.prototype.getSrcset = function(elem) {\n  if (this.wombat.wb_getAttribute) {\n    return this.wombat.wb_getAttribute.call(elem, 'srcset');\n  }\n  return elem.getAttribute('srcset');\n};\n\n/**\n * Returns the correct rewrite modifier for the supplied element\n * @param {Element} elem\n * @return {string}\n */\nAutoFetcher.prototype.rwMod = function(elem) {\n  switch (elem.tagName) {\n    case 'SOURCE':\n      if (elem.parentElement && elem.parentElement.tagName === 'PICTURE') {\n        return 'im_';\n      }\n      return 'oe_';\n    case 'IMG':\n      return 'im_';\n  }\n  return 'oe_';\n};\n\n/**\n * Extracts the media rules from stylesheets and the (data-)srcset URLs from\n * image elements the current context's document contains\n */\nAutoFetcher.prototype.extractFromLocalDoc = function() {\n  // get the values to be preserved from the documents stylesheets\n  // and all img, video, audio elements with (data-)?srcset or data-src\n  var afw = this;\n  Promise.resolve().then(function() {\n    var msg = {\n      type: 'values',\n      context: { docBaseURI: document.baseURI }\n    };\n    var media = [];\n    var i = 0;\n    var sheets = document.styleSheets;\n    for (; i < sheets.length; ++i) {\n      media = media.concat(afw.extractMediaRulesFromSheet(sheets[i]));\n    }\n    var elems = document.querySelectorAll(afw.elemSelector);\n    var srcset = { values: [], presplit: false };\n    var src = { values: [] };\n    var elem, srcv, mod;\n    for (i = 0; i < elems.length; ++i) {\n      elem = elems[i];\n      // we want the original src value in order to resolve URLs in the worker when needed\n      srcv = elem.src ? elem.src : null;\n      // a from value of 1 indicates images and a 2 indicates audio/video\n      mod = afw.rwMod(elem);\n      if (elem.srcset) {\n        srcset.values.push({\n          srcset: afw.getSrcset(elem),\n          mod: mod,\n          tagSrc: srcv\n        });\n      }\n      if (elem.dataset.srcset) {\n        srcset.values.push({\n          srcset: elem.dataset.srcset,\n          mod: mod,\n          tagSrc: srcv\n        });\n      }\n      if (elem.dataset.src) {\n        src.values.push({ src: elem.dataset.src, mod: mod });\n      }\n      if (elem.tagName === 'SOURCE' && srcv) {\n        src.values.push({ src: srcv, mod: mod });\n      }\n    }\n    if (media.length) {\n      msg.media = media;\n    }\n    if (srcset.values.length) {\n      msg.srcset = srcset;\n    }\n    if (src.values.length) {\n      msg.src = src;\n    }\n    if (msg.media || msg.srcset || msg.src) {\n      afw.postMessage(msg);\n    }\n  });\n};\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/autoFetcher.js?")},"../wombat/src/customStorage.js":
/*!**************************************!*\
  !*** ../wombat/src/customStorage.js ***!
  \**************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Storage\": () => (/* binding */ Storage),\n/* harmony export */   \"createStorage\": () => (/* binding */ createStorage)\n/* harmony export */ });\n/* harmony import */ var _wombatUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wombatUtils */ \"../wombat/src/wombatUtils.js\");\n\n\nvar WOMBAT = Symbol('__wb__storage_WOMBAT');\nvar TYPE = Symbol('__wb__storage_TYPE');\n\n/**\n * A re-implementation of the Storage interface.\n * This re-implementation is required for replay in order to ensure\n * that web pages that require local or session storage work as expected as\n * there is sometimes a limit on the amount of storage space that can be used.\n * This re-implementation ensures that limit is unlimited as it would be in\n * the live-web.\n * @param {Wombat} wombat\n * @param {string} type\n * @param {object} initData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Storage\n * @see https://html.spec.whatwg.org/multipage/webstorage.html#the-storage-interface\n */\nfunction Storage(wombat, type, initData) {\n  if (_wombatUtils__WEBPACK_IMPORTED_MODULE_0__.ThrowExceptions.yes) {\n    // there is no constructor exposed for this interface however there is an\n    // interface object exposed, thus we must throw an TypeError if userland\n    // attempts to create us\n    throw new TypeError('Illegal constructor');\n  }\n\n  if (initData && initData.length) {\n    for (var i = 0; i < initData.length; i++) {\n      this[initData[i][0]] = initData[i][1].toString();\n    }\n  }\n\n  Object.defineProperty(this, WOMBAT, {\n    value: wombat,\n    enumerable: false\n  });\n\n  Object.defineProperty(this, TYPE, {\n    value: type,\n    enumerable: false\n  });\n\n  var props = {};\n}\n\nfunction storageProxyHandler() {\n  return {\n    get: function(target, prop) {\n      var proto = target.__proto__;\n\n      if (prop === '__proto__') {\n        return proto;\n      }\n\n      if (proto.hasOwnProperty(prop) || (proto.__proto__ && proto.__proto__.hasOwnProperty(prop))) {\n        var res = target[prop];\n\n        if (typeof(res) === 'function') {\n          res = res.bind(target);\n        }\n\n        return res;\n      }\n\n      return target.hasOwnProperty(prop) ? target.getItem(prop) : undefined;\n    },\n\n    set: function(target, prop, value) {\n      if (target.__proto__.hasOwnProperty(prop)) {\n        target[prop] = value;\n        return true;\n      }\n\n      target.setItem(prop, value);\n      return true;\n    }\n  };\n};\n\nfunction createStorage(wombat, type, initData) {\n  var storage = new Storage(wombat, type, initData);\n\n  if (wombat.$wbwindow.Proxy) {\n    storage = new wombat.$wbwindow.Proxy(storage, storageProxyHandler());\n  }\n\n  wombat.defGetterProp(wombat.$wbwindow, type, function() {\n    return storage;\n  });\n\n  return storage;\n}\n\n/**\n * When passed a key name, will return that key's value\n * @param {string} name\n * @return {*}\n */\nStorage.prototype.getItem = function getItem(name) {\n  return this.hasOwnProperty(name) ? this[name] : null;\n};\n\n/**\n * When passed a key name and value, will add that key to the storage,\n * or update that key's value if it already exists\n * @param {string} name\n * @param {*} value\n * @return {*}\n */\nStorage.prototype.setItem = function setItem(name, value) {\n  var sname = String(name);\n  var svalue = String(value);\n  var old = this.getItem(sname);\n  this[sname] = value;\n  this.fireEvent(sname, old, svalue);\n  return undefined;\n};\n\nStorage.prototype._deleteItem = function(item) {\n  delete this[item];\n};\n\n/**\n * When passed a key name, will remove that key from the storage\n * @param {string} name\n * @return {undefined}\n */\nStorage.prototype.removeItem = function removeItem(name) {\n  var old = this.getItem(name);\n  this._deleteItem(name);\n  this.fireEvent(name, old, null);\n  return undefined;\n};\n\n\n/**\n * When invoked, will empty all keys out of the storage\n * @return {undefined}\n */\nStorage.prototype.clear = function clear() {\n  for (var member in this) {\n    delete this[member];\n  }\n\n  this.fireEvent(null, null, null);\n  return undefined;\n};\n\n/**\n * When passed a number n, this method will return the name of the nth key in the storage\n * @param {number} index\n * @return {*}\n */\nStorage.prototype.key = function key(index) {\n  var n = (0,_wombatUtils__WEBPACK_IMPORTED_MODULE_0__.ensureNumber)(index);\n  if (n == null || n < 0) return null;\n  var keys = Object.keys(this);\n  if (n < keys.length) return keys[n];\n  return null;\n};\n\n/**\n * Because we are re-implementing the storage interface we must fire StorageEvent\n * ourselves, this function does just that.\n * @param {?string} key\n * @param {*} oldValue\n * @param {*} newValue\n * @see https://html.spec.whatwg.org/multipage/webstorage.html#send-a-storage-notification\n */\nStorage.prototype.fireEvent = function fireEvent(key, oldValue, newValue) {\n  var sevent = new StorageEvent('storage', {\n    key: key,\n    newValue: newValue,\n    oldValue: oldValue,\n    url: this[WOMBAT].$wbwindow.WB_wombat_location.href\n  });\n  // storage is a read only property of StorageEvent\n  // that must be on the fired instance of the event\n  Object.defineProperty(sevent, 'storageArea', {\n    value: this,\n    writable: false,\n    configurable: false\n  });\n  sevent._storageArea = this;\n  this[WOMBAT].storage_listeners.map(sevent);\n};\n\n/**\n * An override of the valueOf function that returns wombat's Proxy for the\n * specific storage this class is for, either local or session storage.\n * @return {Proxy<Storage>}\n */\nStorage.prototype.valueOf = function valueOf() {\n  return this[WOMBAT].$wbwindow[this[TYPE]];\n};\n\n\n/**\n * An override of toString to return '[object Storage]'\n **/\nStorage.prototype.toString = function() {\n  return '[object Storage]';\n};\n\n\n\n// the length getter is on the prototype (__proto__ modern browsers)\nObject.defineProperty(Storage.prototype, 'length', {\n  enumerable: false,\n  get: function length() {\n    return Object.keys(this).length;\n  }\n});\n\n(0,_wombatUtils__WEBPACK_IMPORTED_MODULE_0__.addToStringTagToClass)(Storage, 'Storage');\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/customStorage.js?")},"../wombat/src/funcMap.js":
/*!********************************!*\
  !*** ../wombat/src/funcMap.js ***!
  \********************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FuncMap)\n/* harmony export */ });\n/**\n * A class that manages event listeners for the override applied to\n * EventTarget.[addEventListener, removeEventListener]\n */\nfunction FuncMap() {\n  /**\n   * @type {Array<Function[]>}\n   * @private\n   */\n  this._map = [];\n}\n\n/**\n * Adds a mapping of original listener -> wrapped original listener\n * @param {Function} fnKey - The original listener function\n * @param {Function} fnValue - The wrapped original listener function\n */\nFuncMap.prototype.set = function(fnKey, fnValue) {\n  this._map.push([fnKey, fnValue]);\n};\n\n/**\n * Returns the wrapped original listener that is mapped to the supplied function\n * if it exists in the FuncMap's mapping\n * @param {Function} fnKey - The original listener function\n * @return {?Function}\n */\nFuncMap.prototype.get = function(fnKey) {\n  for (var i = 0; i < this._map.length; i++) {\n    if (this._map[i][0] === fnKey) {\n      return this._map[i][1];\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the wrapper for the supplied original function\n * if it exists in the FuncMap's mapping\n * @param {Function} fnKey - The original listener function\n * @return {number}\n */\nFuncMap.prototype.find = function(fnKey) {\n  for (var i = 0; i < this._map.length; i++) {\n    if (this._map[i][0] === fnKey) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Returns the wrapped original listener function for the supplied original\n * listener function. If the wrapped original listener does not exist in\n * FuncMap's mapping it is added.\n * @param {Function} func - The original listener function\n * @param {Function} initter - The a function that returns a wrapped version\n * of the original listener function\n * @return {?Function}\n */\nFuncMap.prototype.add_or_get = function(func, initter) {\n  var fnValue = this.get(func);\n  if (!fnValue) {\n    fnValue = initter();\n    this.set(func, fnValue);\n  }\n  return fnValue;\n};\n\n/**\n * Removes the mapping of the original listener function to its wrapped counter part\n * @param {Function} func - The original listener function\n * @return {?Function}\n */\nFuncMap.prototype.remove = function(func) {\n  var idx = this.find(func);\n  if (idx >= 0) {\n    var fnMapping = this._map.splice(idx, 1);\n    return fnMapping[0][1];\n  }\n  return null;\n};\n\n/**\n * Calls all wrapped listener functions contained in the FuncMap's mapping\n * with the supplied param\n * @param {*} param\n */\nFuncMap.prototype.map = function(param) {\n  for (var i = 0; i < this._map.length; i++) {\n    this._map[i][1](param);\n  }\n};\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/funcMap.js?")},"../wombat/src/listeners.js":
/*!**********************************!*\
  !*** ../wombat/src/listeners.js ***!
  \**********************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrapEventListener\": () => (/* binding */ wrapEventListener),\n/* harmony export */   \"wrapSameOriginEventListener\": () => (/* binding */ wrapSameOriginEventListener)\n/* harmony export */ });\n/* eslint-disable camelcase */\n\n/**\n *\n * @param {Function} origListener\n * @param {Window} win\n * @return {Function}\n */\nfunction wrapSameOriginEventListener(origListener, win) {\n  return function wrappedSameOriginEventListener(event) {\n    if (window != win) {\n      return;\n    }\n    return origListener(event);\n  };\n}\n\n/**\n * @param {Function} origListener\n * @param {Object} obj\n * @param {Wombat} wombat\n * @return {Function}\n */\nfunction wrapEventListener(origListener, obj, wombat) {\n  var origListenerFunc;\n\n  // if a function, just use that\n  if (typeof(origListener) === 'function') {\n    origListenerFunc = origListener;\n  // if an EventHandler object, use its handleEvent() bound method\n  } else if (typeof(origListener) === 'object') {\n    origListenerFunc = origListener.handleEvent.bind(origListener);\n  // else do nothing!\n  } else {\n    origListenerFunc = function() {};\n  }\n\n  return function wrappedEventListener(event) {\n    var ne;\n\n    if (event.data && event.data.from && event.data.message) {\n      if (\n        event.data.to_origin !== '*' &&\n        obj.WB_wombat_location &&\n        !wombat.startsWith(event.data.to_origin, obj.WB_wombat_location.origin)\n      ) {\n        console.warn(\n          'Skipping message event to ' +\n            event.data.to_origin +\n            ' doesn\\'t start with origin ' +\n            obj.WB_wombat_location.origin\n        );\n        return;\n      }\n\n      var source = event.source;\n\n      if (event.data.from_top) {\n        source = obj.__WB_top_frame;\n      } else if (\n        event.data.src_id &&\n        obj.__WB_win_id &&\n        obj.__WB_win_id[event.data.src_id]\n      ) {\n        source = obj.__WB_win_id[event.data.src_id];\n      }\n\n      ne = new MessageEvent('message', {\n        bubbles: event.bubbles,\n        cancelable: event.cancelable,\n        data: event.data.message,\n        origin: event.data.from,\n        lastEventId: event.lastEventId,\n        source: wombat.proxyToObj(source),\n        ports: event.ports\n      });\n\n      ne._target = event.target;\n      ne._srcElement = event.srcElement;\n      ne._currentTarget = event.currentTarget;\n      ne._eventPhase = event.eventPhase;\n    } else {\n      ne = event;\n    }\n\n    return origListenerFunc(ne);\n  };\n}\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/listeners.js?")},"../wombat/src/wbWombat.js":
/*!*********************************!*\
  !*** ../wombat/src/wbWombat.js ***!
  \*********************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wombat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wombat */ "../wombat/src/wombat.js");\n\n\nwindow._WBWombat = _wombat__WEBPACK_IMPORTED_MODULE_0__["default"];\nwindow._WBWombatInit = function(wbinfo) {\n  if (!this._wb_wombat) {\n    var wombat = new _wombat__WEBPACK_IMPORTED_MODULE_0__["default"](this, wbinfo);\n    this._wb_wombat = wombat.wombatInit();\n  } else {\n    this._wb_wombat.init_paths(wbinfo);\n  }\n};\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/wbWombat.js?')},"../wombat/src/wombat.js":
/*!*******************************!*\
  !*** ../wombat/src/wombat.js ***!
  \*******************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _funcMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./funcMap.js */ \"../wombat/src/funcMap.js\");\n/* harmony import */ var _customStorage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./customStorage.js */ \"../wombat/src/customStorage.js\");\n/* harmony import */ var _wombatLocation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wombatLocation.js */ \"../wombat/src/wombatLocation.js\");\n/* harmony import */ var _autoFetcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autoFetcher.js */ \"../wombat/src/autoFetcher.js\");\n/* harmony import */ var _listeners_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./listeners.js */ \"../wombat/src/listeners.js\");\n/* harmony import */ var _wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wombatUtils.js */ \"../wombat/src/wombatUtils.js\");\n/* harmony import */ var warcio_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! warcio/utils */ \"../wombat/node_modules/warcio/dist/utils.js\");\n/* eslint-disable camelcase */\n\n\n\n\n\n\n\n\n\n\n/**\n * @param {Window} $wbwindow\n * @param {Object} wbinfo\n */\nfunction Wombat($wbwindow, wbinfo) {\n  if (!(this instanceof Wombat)) return new Wombat($wbwindow, wbinfo);\n\n  /** @type {boolean} */\n  this.debug_rw = false;\n\n  /** @type {Window} */\n  this.$wbwindow = $wbwindow;\n  this.WBWindow = Window;\n\n  this.origHost = $wbwindow.location.host;\n  this.origHostname = $wbwindow.location.hostname;\n  this.origProtocol = $wbwindow.location.protocol;\n\n  /** @type {string} */\n  this.HTTP_PREFIX = 'http://';\n\n  /** @type {string} */\n  this.HTTPS_PREFIX = 'https://';\n\n  /** @type {string} */\n  this.REL_PREFIX = '//';\n\n  /** @type {Array<string>} */\n  this.VALID_PREFIXES = [this.HTTP_PREFIX, this.HTTPS_PREFIX, this.REL_PREFIX];\n\n  /** @type {Array<string>} */\n  this.IGNORE_PREFIXES = [\n    '#',\n    'about:',\n    'data:',\n    'blob:',\n    'mailto:',\n    'javascript:',\n    '{',\n    '*'\n  ];\n  if ('ignore_prefixes' in wbinfo) {\n    this.IGNORE_PREFIXES = this.IGNORE_PREFIXES.concat(wbinfo.ignore_prefixes);\n  }\n\n  this.WB_CHECK_THIS_FUNC = '_____WB$wombat$check$this$function_____';\n  this.WB_ASSIGN_FUNC = '_____WB$wombat$assign$function_____';\n\n  /** @type {function(qualifiedName: string, value: string): void} */\n  this.wb_setAttribute = $wbwindow.Element.prototype.setAttribute;\n\n  /** @type {function(qualifiedName: string): ?string} */\n  this.wb_getAttribute = $wbwindow.Element.prototype.getAttribute;\n\n  /** @type {function(): string} */\n  this.wb_funToString = Function.prototype.toString;\n\n  /** @type {AutoFetcher} */\n  this.WBAutoFetchWorker = null;\n\n  /** @type {boolean} */\n  this.wbUseAFWorker =\n    wbinfo.enable_auto_fetch && $wbwindow.Worker != null && wbinfo.is_live;\n\n  /** @type {string} */\n  this.wb_rel_prefix = '';\n\n  /** @type {boolean} */\n  this.wb_wombat_updating = false;\n\n  /** @type {FuncMap} */\n  this.message_listeners = new _funcMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n  /** @type {FuncMap} */\n  this.storage_listeners = new _funcMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n  /**\n   * rewrite modifiers for <link href=\"URL\" rel=\"import|preload\" as=\"x\">\n   * expressed as as-value -> modifier\n   * @type {Object}\n   */\n  this.linkAsTypes = {\n    script: 'js_',\n    worker: 'js_',\n    style: 'cs_',\n    image: 'im_',\n    document: 'if_',\n    fetch: 'mp_',\n    font: 'oe_',\n    audio: 'oe_',\n    video: 'oe_',\n    embed: 'oe_',\n    object: 'oe_',\n    track: 'oe_',\n    // the following cover the default case\n    '': 'mp_',\n    null: 'mp_',\n    undefined: 'mp_'\n  };\n\n  /**\n   * rewrite modifiers for <link href=\"URL\" rel=\"x\"> and or\n   * <link href=\"URL\" rel=\"x\" as=\"y\"> expressed as a mapping of\n   * rel -> modifier or rel -> as -> modifier\n   * @type {Object}\n   */\n  this.linkTagMods = {\n    linkRelToAs: {\n      import: this.linkAsTypes,\n      preload: this.linkAsTypes\n    },\n    stylesheet: 'cs_',\n    // the following cover the default case\n    null: 'mp_',\n    undefined: 'mp_',\n    '': 'mp_'\n  };\n\n  /**\n   * pre-computed modifiers for each tag\n   * @type {Object}\n   */\n  this.tagToMod = {\n    A: { href: 'mp_' },\n    AREA: { href: 'mp_' },\n    AUDIO: { src: 'oe_', poster: 'im_' },\n    BASE: { href: 'mp_' },\n    EMBED: { src: 'oe_' },\n    FORM: { action: 'mp_' },\n    FRAME: { src: 'fr_' },\n    IFRAME: { src: 'if_' },\n    IMAGE: { href: 'im_', 'xlink:href': 'im_' },\n    IMG: { src: 'im_', srcset: 'im_' },\n    INPUT: { src: 'oe_' },\n    INS: { cite: 'mp_' },\n    META: { content: 'mp_' },\n    OBJECT: { data: 'oe_', codebase: 'oe_' },\n    Q: { cite: 'mp_' },\n    // covers both HTML and SVG script element,\n    SCRIPT: { src: 'js_', 'xlink:href': 'js_' },\n    SOURCE: { src: 'oe_', srcset: 'oe_' },\n    TRACK: { src: 'oe_' },\n    VIDEO: { src: 'oe_', poster: 'im_' },\n    image: { href: 'im_', 'xlink:href': 'im_' }\n  };\n\n  /** @type {Array<string>} */\n  this.URL_PROPS = [\n    'href',\n    'hash',\n    'pathname',\n    'host',\n    'hostname',\n    'protocol',\n    'origin',\n    'search',\n    'port'\n  ];\n\n  /** @type {Object} */\n  this.wb_info = wbinfo;\n\n  /**\n   * custom options\n   * @type {Object}\n   */\n  this.wb_opts = wbinfo.wombat_opts;\n\n  /** @type {string} */\n  this.wb_replay_prefix = wbinfo.prefix;\n\n  /** @type {boolean} */\n  this.wb_is_proxy = this.wb_info.proxy_magic || !this.wb_replay_prefix;\n\n  /** @type {string} */\n  this.wb_info.top_host = this.wb_info.top_host || '*';\n\n  /** @type {string} */\n  this.wb_curr_host =\n    $wbwindow.location.protocol + '//' + $wbwindow.location.host;\n\n  /** @type {Object} */\n  this.wb_info.wombat_opts = this.wb_info.wombat_opts || {};\n\n  /** @type {string} */\n  this.wb_orig_scheme = this.wb_info.wombat_scheme + '://';\n  /** @type {string} */\n  this.wb_orig_origin = this.wb_orig_scheme + this.wb_info.wombat_host;\n\n  /** @type {string} */\n  this.wb_abs_prefix = this.wb_replay_prefix;\n\n  /** @type {string} */\n  this.wb_capture_date_part = '';\n  if (!this.wb_info.is_live && this.wb_info.wombat_ts) {\n    this.wb_capture_date_part = '/' + this.wb_info.wombat_ts + '/';\n  }\n\n  /** @type {Array<string>} */\n  this.BAD_PREFIXES = [\n    'http:' + this.wb_replay_prefix,\n    'https:' + this.wb_replay_prefix,\n    'http:/' + this.wb_replay_prefix,\n    'https:/' + this.wb_replay_prefix\n  ];\n\n  /** @type {RegExp} */\n  this.hostnamePortRe = /^[\\w-]+(\\.[\\w-_]+)+(:\\d+)(\\/|$)/;\n\n  /** @type {RegExp} */\n  this.ipPortRe = /^\\d+\\.\\d+\\.\\d+\\.\\d+(:\\d+)?(\\/|$)/;\n\n  /** @type {RegExp} */\n  this.workerBlobRe = /__WB_pmw\\(.*?\\)\\.(?=postMessage\\()/g;\n  /** @type {RegExp} */\n  this.rmCheckThisInjectRe = /_____WB\\$wombat\\$check\\$this\\$function_____\\(.*?\\)/g;\n\n  /** @type {RegExp} */\n  this.STYLE_REGEX = /(url\\s*\\(\\s*[\\\\\"']*)([^)'\"]+)([\\\\\"']*\\s*\\))/gi;\n\n  /** @type {RegExp} */\n  this.IMPORT_REGEX = /(@import\\s*[\\\\\"']*)([^)'\";]+)([\\\\\"']*\\s*;?)/gi;\n\n  /** @type {RegExp} */\n  this.IMPORT_JS_REGEX = /^(import\\s*\\(['\"]+)([^'\"]+)([\"'])/i;\n\n  /** @type {RegExp} */\n  this.no_wombatRe = /WB_wombat_/g;\n\n  /** @type {RegExp} */\n  this.srcsetRe = /\\s*(\\S*\\s+[\\d.]+[wx]),|(?:\\s*,(?:\\s+|(?=https?:)))/;\n\n  /** @type {RegExp} */\n  this.cookie_path_regex = /\\bPath='?\"?([^;'\"\\s]+)/i;\n\n  /** @type {RegExp} */\n  this.cookie_domain_regex = /\\bDomain=([^;'\"\\s]+)/i;\n\n  /** @type {RegExp} */\n  this.cookie_expires_regex = /\\bExpires=([^;'\"]+)/gi;\n\n  /** @type {RegExp} */\n  this.SetCookieRe = /,(?![|])/;\n\n  /** @type {RegExp} */\n  this.IP_RX = /^(\\d)+\\.(\\d)+\\.(\\d)+\\.(\\d)+$/;\n\n  /** @type {RegExp} */\n  this.FullHTMLRegex = /^\\s*<(?:html|head|body|!doctype html)/i;\n\n  /** @type {RegExp} */\n  this.IsTagRegex = /^\\s*</;\n\n  /** @type {RegExp} */\n  this.DotPostMessageRe = /(\\.postMessage\\s*\\()/;\n\n  /** @type {RegExp} */\n  this.extractPageUnderModifierRE = /\\/(?:[0-9]{14})?([a-z]{2, 3}_)\\//;\n\n  /** @type {string} */\n  this.write_buff = '';\n\n  var eTargetProto = ($wbwindow.EventTarget || {}).prototype;\n  /** @type {Object} */\n  this.utilFns = {\n    cspViolationListener: function(e) {\n      console.group('CSP Violation');\n      console.log('Replayed Page URL', window.WB_wombat_location.href);\n      console.log('The documentURI', e.documentURI);\n      console.log('The blocked URL', e.blockedURI);\n      console.log('The directive violated', e.violatedDirective);\n      console.log('Our policy', e.originalPolicy);\n      if (e.sourceFile) {\n        var fileInfo = 'File: ' + e.sourceFile;\n        if (e.lineNumber && e.columnNumber) {\n          fileInfo += ' @ ' + e.lineNumber + ':' + e.columnNumber;\n        } else if (e.lineNumber) {\n          fileInfo += ' @ ' + e.lineNumber;\n        }\n        console.log(fileInfo);\n      }\n      console.groupEnd();\n    },\n    addEventListener: eTargetProto.addEventListener,\n    removeEventListener: eTargetProto.removeEventListener,\n    // some sites do funky things with the toString function\n    // (e.g. if used throw error or deny operation) hence we\n    // need a surefire and safe way to tell us what an object\n    // or function is hence Objects native toString\n    objToString: Object.prototype.toString,\n    wbSheetMediaQChecker: null,\n    XHRopen: null,\n    XHRsend: null\n  };\n  /**\n   * @type {{yesNo: boolean, added: boolean}}\n   */\n  this.showCSPViolations = { yesNo: false, added: false };\n  (0,_wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.autobind)(this);\n  // this._addRemoveCSPViolationListener(true);\n}\n\n/**\n * Performs the initialization of wombat's internals:\n *  - {@link initTopFrame}\n *  - {@link initWombatLoc}\n *  - {@link initWombatTop}\n *  - {@link initAutoFetchWorker}\n *  - initializes the wb_rel_prefix property\n *  - initializes the wb_unrewrite_rx property\n *  - if we are in framed replay mode and the wb_info mod is not bn_\n *    {@link initTopFrameNotify} is called\n * @private\n */\nWombat.prototype._internalInit = function() {\n  this.initTopFrame(this.$wbwindow);\n  this.initWombatLoc(this.$wbwindow);\n  this.initWombatTop(this.$wbwindow);\n  // updated wb_unrewrite_rx for imgur.com\n  var wb_origin = this.$wbwindow.__WB_replay_top.location.origin;\n  var wb_host = this.$wbwindow.__WB_replay_top.location.host;\n  var wb_proto = this.$wbwindow.__WB_replay_top.location.protocol;\n  if (this.wb_replay_prefix && this.wb_replay_prefix.indexOf(wb_origin) === 0) {\n    this.wb_rel_prefix = this.wb_replay_prefix.substring(wb_origin.length);\n  } else {\n    this.wb_rel_prefix = this.wb_replay_prefix;\n  }\n  this.wb_prefixes = [this.wb_abs_prefix, this.wb_rel_prefix];\n\n  // make the protocol and host optional now\n  var rx =\n    '((' + wb_proto + ')?//' + wb_host + ')?' + this.wb_rel_prefix + '[^/]+/';\n  this.wb_unrewrite_rx = new RegExp(rx, 'g');\n\n  if (this.wb_info.is_framed && this.wb_info.mod !== 'bn_') {\n    this.initTopFrameNotify(this.wb_info);\n  }\n  this.initAutoFetchWorker();\n};\n\n/**\n * Internal function that adds a \"securitypolicyviolation\" event listener\n * to the document that will log any CSP violations in a nicer way than\n * is the default\n *\n * If the yesNo argument is true, the event listener is added, otherwise\n * it is removed\n * @param {boolean} yesNo\n * @private\n */\nWombat.prototype._addRemoveCSPViolationListener = function(yesNo) {\n  this.showCSPViolations.yesNo = yesNo;\n  if (this.showCSPViolations.yesNo && !this.showCSPViolations.added) {\n    this.showCSPViolations.added = true;\n    this._addEventListener(\n      document,\n      'securitypolicyviolation',\n      this.utilFns.cspViolationListener\n    );\n  } else {\n    this.showCSPViolations.added = false;\n    this._removeEventListener(\n      document,\n      'securitypolicyviolation',\n      this.utilFns.cspViolationListener\n    );\n  }\n};\n\n/**\n * Adds the supplied event listener on the supplied event target\n * @param {Object} obj\n * @param {string} event\n * @param {Function} fun\n * @return {*}\n * @private\n */\nWombat.prototype._addEventListener = function(obj, event, fun) {\n  if (this.utilFns.addEventListener) {\n    return this.utilFns.addEventListener.call(obj, event, fun);\n  }\n  obj.addEventListener(event, fun);\n};\n\n/**\n * Removes the supplied event listener on the supplied event target\n * @param {Object} obj\n * @param {string} event\n * @param {Function} fun\n * @return {*}\n * @private\n */\nWombat.prototype._removeEventListener = function(obj, event, fun) {\n  if (this.utilFns.removeEventListener) {\n    return this.utilFns.removeEventListener.call(obj, event, fun);\n  }\n  obj.removeEventListener(event, fun);\n};\n\n/**\n * Extracts the modifier (i.e. mp\\_, if\\_, ...) the page is under that wombat is\n * operating in. If extracting the modifier fails for some reason mp\\_ is returned.\n * Used to ensure the correct modifier is used for rewriting the service workers scope.\n * @return {string}\n */\nWombat.prototype.getPageUnderModifier = function() {\n  try {\n    var pageUnderModifier = this.extractPageUnderModifierRE.exec(\n      location.pathname\n    );\n    if (pageUnderModifier && pageUnderModifier[1]) {\n      var mod = pageUnderModifier[1].trim();\n      return mod || 'mp_';\n    }\n  } catch (e) {}\n  return 'mp_';\n};\n\n/**\n * Returns T/F indicating if the supplied function is a native function\n * or not. The test checks for the presence of the substring `'[native code]'`\n * in the result of calling `toString` on the function\n * @param {Function} funToTest - The function to be tested\n * @return {boolean}\n */\nWombat.prototype.isNativeFunction = function(funToTest) {\n  if (!funToTest || typeof funToTest !== 'function') return false;\n  var str = this.wb_funToString.call(funToTest);\n\n  if (str.indexOf('[native code]') == -1) {\n    return false;\n  }\n  if (funToTest.__WB_is_native_func__ !== undefined) {\n    return !!funToTest.__WB_is_native_func__;\n  }\n  return true;\n};\n\n/**\n * Returns T/F indicating if the supplied argument is a string or not\n * @param {*} arg\n * @return {boolean}\n */\nWombat.prototype.isString = function(arg) {\n  return arg != null && Object.getPrototypeOf(arg) === String.prototype;\n};\n\n\n/**\n * Create blob for content, convert to service-worker based blob URL\n * set iframe to remove blob URL on unload\n *\n*/\n\nWombat.prototype.blobUrlForIframe = function(iframe, string) {\n  var blob = new Blob([string], {type: 'text/html'});\n  var url = URL.createObjectURL(blob);\n\n  iframe.__wb_blobSrc = url;\n  iframe.addEventListener('load', function() {\n    if (iframe.__wb_blobSrc) {\n      URL.revokeObjectURL(iframe.__wb_blobSrc);\n      iframe.__wb_blobSrc = null;\n    }\n  }, {once: true});\n\n  iframe.__wb_origSrc = iframe.src;\n  var blobIdUrl = url.slice(url.lastIndexOf('/') + 1) + '/' + this.wb_info.url;\n  iframe.src = this.wb_info.prefix + this.wb_info.request_ts + 'mp_/blob:' + blobIdUrl;\n};\n\n/**\n * Returns T/F indicating if the supplied element may have attributes that\n * are auto-fetched\n * @param {Element} elem\n * @return {boolean}\n */\nWombat.prototype.isSavedSrcSrcset = function(elem) {\n  switch (elem.tagName) {\n    case 'IMG':\n    case 'VIDEO':\n    case 'AUDIO':\n      return true;\n    case 'SOURCE':\n      if (!elem.parentElement) return false;\n      switch (elem.parentElement.tagName) {\n        case 'PICTURE':\n        case 'VIDEO':\n        case 'AUDIO':\n          return true;\n        default:\n          return false;\n      }\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns T/F indicating if the supplied element is an Image element that\n * may have srcset values to be sent to the backing auto-fetch worker\n * @param {Element} elem\n * @return {boolean}\n */\nWombat.prototype.isSavedDataSrcSrcset = function(elem) {\n  if (elem.dataset && elem.dataset.srcset != null) {\n    return this.isSavedSrcSrcset(elem);\n  }\n  return false;\n};\n\n/**\n * Determines if the supplied string is an host URL\n * @param {string} str\n * @return {boolean}\n */\nWombat.prototype.isHostUrl = function(str) {\n  // Good guess that's its a hostname\n  if (str.indexOf('www.') === 0) {\n    return true;\n  }\n\n  // hostname:port (port required)\n  var matches = str.match(this.hostnamePortRe);\n  if (matches && matches[0].length < 64) {\n    return true;\n  }\n\n  // ip:port\n  matches = str.match(this.ipPortRe);\n  if (matches) {\n    return matches[0].length < 64;\n  }\n  return false;\n};\n\n/**\n * Returns T/F indicating if the supplied object is the arguments object\n * @param {*} maybeArgumentsObj\n * @return {boolean}\n */\nWombat.prototype.isArgumentsObj = function(maybeArgumentsObj) {\n  if (\n    !maybeArgumentsObj ||\n    !(typeof maybeArgumentsObj.toString === 'function')\n  ) {\n    return false;\n  }\n  try {\n    return (\n      this.utilFns.objToString.call(maybeArgumentsObj) === '[object Arguments]'\n    );\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Ensures that each element in the supplied arguments object or\n * array is deproxied handling cases where we can not modify the\n * supplied object returning a new or modified object with the\n * exect elements/properties\n * @param {*} maybeArgumentsObj\n * @return {*}\n */\nWombat.prototype.deproxyArrayHandlingArgumentsObj = function(\n  maybeArgumentsObj\n) {\n  if (\n    !maybeArgumentsObj ||\n    maybeArgumentsObj instanceof NodeList ||\n    !maybeArgumentsObj.length\n  ) {\n    return maybeArgumentsObj;\n  }\n  var args = this.isArgumentsObj(maybeArgumentsObj)\n    ? new Array(maybeArgumentsObj.length)\n    : maybeArgumentsObj;\n  for (var i = 0; i < maybeArgumentsObj.length; ++i) {\n    const res = this.proxyToObj(maybeArgumentsObj[i]);\n    if (res !== args[i]) {\n      args[i] = res;\n    }\n  }\n  return args;\n};\n\n/**\n * Determines if a string starts with the supplied prefix.\n * If it does the matching prefix is returned otherwise undefined.\n * @param {?string} string\n * @param {string} prefix\n * @return {?string}\n */\nWombat.prototype.startsWith = function(string, prefix) {\n  if (!string) return undefined;\n  return string.indexOf(prefix) === 0 ? prefix : undefined;\n};\n\n/**\n * Determines if a string starts with the supplied array of prefixes.\n * If it does the matching prefix is returned otherwise undefined.\n * @param {?string} string\n * @param {Array<string>} prefixes\n * @return {?string}\n */\nWombat.prototype.startsWithOneOf = function(string, prefixes) {\n  if (!string) return undefined;\n  for (var i = 0; i < prefixes.length; i++) {\n    if (string.indexOf(prefixes[i]) === 0) {\n      return prefixes[i];\n    }\n  }\n  return undefined;\n};\n\n/**\n * Determines if a string ends with the supplied suffix.\n * If it does the suffix is returned otherwise undefined.\n * @param {?string} str\n * @param {string} suffix\n * @return {?string}\n */\nWombat.prototype.endsWith = function(str, suffix) {\n  if (!str) return undefined;\n  if (str.indexOf(suffix, str.length - suffix.length) !== -1) {\n    return suffix;\n  }\n  return undefined;\n};\n\n/**\n * Returns T/F indicating if the supplied tag name and attribute name\n * combination are to be rewritten\n * @param {string} tagName\n * @param {string} attr\n * @return {boolean}\n */\nWombat.prototype.shouldRewriteAttr = function(tagName, attr) {\n  switch (attr) {\n    case 'href':\n    case 'src':\n    case 'xlink:href':\n      return true;\n  }\n  if (\n    tagName &&\n    this.tagToMod[tagName] &&\n    this.tagToMod[tagName][attr] !== undefined\n  ) {\n    return true;\n  }\n  return (\n    (tagName === 'VIDEO' && attr === 'poster') ||\n    (tagName === 'META' && attr === 'content')\n  );\n};\n\n/**\n * Returns T/F indicating if the script tag being rewritten should not\n * have its text contents wrapped based on the supplied script type.\n * @param {?string} scriptType\n * @return {boolean}\n */\nWombat.prototype.skipWrapScriptBasedOnType = function(scriptType) {\n  if (!scriptType) return false;\n  if (scriptType.indexOf('javascript') >= 0 || scriptType.indexOf('ecmascript') >= 0) return false;\n  if (scriptType.indexOf('json') >= 0) return true;\n  if (scriptType.indexOf('text/') >= 0) return true;\n  return false;\n};\n\n/**\n * Returns T/F indicating if the script tag being rewritten should not\n * have its text contents wrapped based on heuristic analysis of its\n * text contents.\n * @param {?string} text\n * @return {boolean}\n */\nWombat.prototype.skipWrapScriptTextBasedOnText = function(text) {\n  if (\n    !text ||\n    text.indexOf(this.WB_ASSIGN_FUNC) >= 0 ||\n    text.indexOf('<') === 0\n  ) {\n    return true;\n  }\n  var override_props = [\n    'window',\n    'self',\n    'document',\n    'location',\n    'top',\n    'parent',\n    'frames',\n    'opener'\n  ];\n\n  for (var i = 0; i < override_props.length; i++) {\n    if (text.indexOf(override_props[i]) >= 0) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns T/F indicating if the supplied DOM Node has child Elements/Nodes.\n * Note this function should be used when the Node(s) being considered can\n * be null/undefined.\n * @param {Node} node\n * @return {boolean}\n */\nWombat.prototype.nodeHasChildren = function(node) {\n  if (!node) return false;\n  if (typeof node.hasChildNodes === 'function') return node.hasChildNodes();\n  var kids = node.children || node.childNodes;\n  if (kids) return kids.length > 0;\n  return false;\n};\n\n/**\n * Returns the correct rewrite modifier for the supplied element and\n * attribute combination if one exists otherwise mp_.\n * Used by\n *  - {@link performAttributeRewrite}\n *  - {@link rewriteFrameSrc}\n *  - {@link initElementGetSetAttributeOverride}\n *  - {@link overrideHrefAttr}\n *\n * @param {*} elem\n * @param {string} attrName\n * @return {?string}\n */\nWombat.prototype.rwModForElement = function(elem, attrName) {\n  if (!elem) return undefined;\n  // the default modifier, if none is supplied to rewrite_url, is mp_\n  var mod = 'mp_';\n  if (elem.tagName === 'LINK' && attrName === 'href') {\n    // link types are always ASCII case-insensitive, and must be compared as such.\n    // https://html.spec.whatwg.org/multipage/links.html#linkTypes\n    if (elem.rel) {\n      var relV = elem.rel.trim().toLowerCase();\n      var asV = this.wb_getAttribute.call(elem, 'as');\n      if (asV && this.linkTagMods.linkRelToAs[relV] != null) {\n        var asMods = this.linkTagMods.linkRelToAs[relV];\n        mod = asMods[asV.toLowerCase()];\n      } else if (this.linkTagMods[relV] != null) {\n        mod = this.linkTagMods[relV];\n      }\n    }\n  } else {\n    // check if this element has an rewrite modifiers and set mod to it if it does\n    var maybeMod = this.tagToMod[elem.tagName];\n    if (maybeMod != null) {\n      mod = maybeMod[attrName];\n    }\n  }\n  return mod;\n};\n\n/**\n * If the supplied element is a script tag and has the server-side rewrite added\n * property \"__wb_orig_src\" it is removed and the \"__$removedWBOSRC$__\" property\n * is added to element as an internal flag indicating no further checks are to be\n * made.\n *\n * See also {@link retrieveWBOSRC}\n * @param {Element} elem\n */\nWombat.prototype.removeWBOSRC = function(elem) {\n  if (elem.tagName === 'SCRIPT' && !elem.__$removedWBOSRC$__) {\n    if (elem.hasAttribute('__wb_orig_src')) {\n      elem.removeAttribute('__wb_orig_src');\n    }\n    elem.__$removedWBOSRC$__ = true;\n  }\n};\n\n/**\n * If the supplied element is a script tag and has the server-side rewrite added\n * property \"__wb_orig_src\" its value is returned otherwise undefined is returned.\n * If the element did not have the \"__wb_orig_src\" property the\n * \"__$removedWBOSRC$__\" property is added to element as an internal flag\n * indicating no further checks are to be made.\n *\n * See also {@link removeWBOSRC}\n * @param {Element} elem\n * @return {?string}\n */\nWombat.prototype.retrieveWBOSRC = function(elem) {\n  if (elem.tagName === 'SCRIPT' && !elem.__$removedWBOSRC$__) {\n    var maybeWBOSRC;\n    if (this.wb_getAttribute) {\n      maybeWBOSRC = this.wb_getAttribute.call(elem, '__wb_orig_src');\n    } else {\n      maybeWBOSRC = elem.getAttribute('__wb_orig_src');\n    }\n    if (maybeWBOSRC == null) elem.__$removedWBOSRC$__ = true;\n    return maybeWBOSRC;\n  }\n  return undefined;\n};\n\n/**\n * Wraps the supplied text contents of a script tag with the required Wombat setup\n * @param {?string} scriptText\n * @return {string}\n */\nWombat.prototype.wrapScriptTextJsProxy = function(scriptText) {\n  return (\n    'var _____WB$wombat$assign$function_____ = function(name) {return ' +\n    '(self._wb_wombat && self._wb_wombat.local_init && self._wb_wombat.local_init(name)) || self[name]; };\\n' +\n    'if (!self.__WB_pmw) { self.__WB_pmw = function(obj) { ' +\n    'this.__WB_source = obj; return this; } }\\n{\\n' +\n    'let window = _____WB$wombat$assign$function_____(\"window\");\\n' +\n    'let globalThis = _____WB$wombat$assign$function_____(\"globalThis\");\\n' +\n    'let self = _____WB$wombat$assign$function_____(\"self\");\\n' +\n    'let document = _____WB$wombat$assign$function_____(\"document\");\\n' +\n    'let location = _____WB$wombat$assign$function_____(\"location\");\\n' +\n    'let top = _____WB$wombat$assign$function_____(\"top\");\\n' +\n    'let parent = _____WB$wombat$assign$function_____(\"parent\");\\n' +\n    'let frames = _____WB$wombat$assign$function_____(\"frames\");\\n' +\n    'let opener = _____WB$wombat$assign$function_____(\"opener\");\\n{\\n' +\n    scriptText.replace(this.DotPostMessageRe, '.__WB_pmw(self.window)$1') +\n    '\\n\\n}}'\n  );\n};\n\n/**\n * Calls the supplied function when the supplied element undergoes mutations\n * @param elem\n * @param func\n * @return {boolean}\n */\nWombat.prototype.watchElem = function(elem, func) {\n  if (!this.$wbwindow.MutationObserver) {\n    return false;\n  }\n  var m = new this.$wbwindow.MutationObserver(function(records, observer) {\n    for (var i = 0; i < records.length; i++) {\n      var r = records[i];\n      if (r.type === 'childList') {\n        for (var j = 0; j < r.addedNodes.length; j++) {\n          func(r.addedNodes[j]);\n        }\n      }\n    }\n  });\n\n  m.observe(elem, {\n    childList: true,\n    subtree: true\n  });\n};\n\n/**\n * Reconstructs the doctype string if the supplied doctype object\n * is non null/undefined. This function is used by {@link rewriteHtmlFull}\n * in order to ensure correctness of rewriting full string of HTML that\n * started with <!doctype ...> since the innerHTML and outerHTML properties\n * do not include that.\n * @param {DocumentType} doctype\n * @return {string}\n */\nWombat.prototype.reconstructDocType = function(doctype) {\n  if (doctype == null) return '';\n  return (\n    '<!doctype ' +\n    doctype.name +\n    (doctype.publicId ? ' PUBLIC \"' + doctype.publicId + '\"' : '') +\n    (!doctype.publicId && doctype.systemId ? ' SYSTEM' : '') +\n    (doctype.systemId ? ' \"' + doctype.systemId + '\"' : '') +\n    '>'\n  );\n};\n\n/**\n * Constructs the final URL for the URL rewriting process\n * @param {boolean} useRel\n * @param {string} mod\n * @param {string} url\n * @return {string}\n */\nWombat.prototype.getFinalUrl = function(useRel, mod, url) {\n  var prefix = useRel ? this.wb_rel_prefix : this.wb_abs_prefix;\n\n  if (mod == null) {\n    mod = this.wb_info.mod;\n  }\n\n  // if live, don't add the timestamp\n  if (!this.wb_info.is_live) {\n    prefix += this.wb_info.wombat_ts;\n  }\n\n  prefix += mod;\n\n  if (prefix[prefix.length - 1] !== '/') {\n    prefix += '/';\n  }\n\n  return prefix + url;\n};\n\n/**\n * Converts the supplied relative URL to an absolute URL using an A tag\n * @param {string} url\n * @param {?Document} doc\n * @return {string}\n */\nWombat.prototype.resolveRelUrl = function(url, doc) {\n  var docObj = doc || this.$wbwindow.document;\n  var parser = this.makeParser(docObj.baseURI, docObj);\n\n  return new URL(url, parser).href;\n};\n\n/**\n * Extracts the original URL from the supplied rewritten URL\n * @param {?string} rewrittenUrl\n * @return {string}\n */\nWombat.prototype.extractOriginalURL = function(rewrittenUrl) {\n  if (!rewrittenUrl) {\n    return '';\n  } else if (this.wb_is_proxy) {\n    // proxy mode: no extraction needed\n    return rewrittenUrl;\n  }\n\n  var rwURLString = rewrittenUrl.toString();\n\n  var url = rwURLString;\n\n  // ignore certain urls\n  if (this.startsWithOneOf(url, this.IGNORE_PREFIXES)) {\n    return url;\n  }\n\n  if (url.startsWith(this.wb_info.static_prefix)) {\n    return url;\n  }\n\n  var start;\n\n  if (this.startsWith(url, this.wb_abs_prefix)) {\n    start = this.wb_abs_prefix.length;\n  } else if (this.wb_rel_prefix && this.startsWith(url, this.wb_rel_prefix)) {\n    start = this.wb_rel_prefix.length;\n  } else {\n    // if no coll, start from beginning, otherwise could be part of coll..\n    start = this.wb_rel_prefix ? 1 : 0;\n  }\n\n  var index = url.indexOf('/http', start);\n  if (index < 0) {\n    index = url.indexOf('///', start);\n  }\n  if (index < 0) {\n    index = url.indexOf('/blob:', start);\n  }\n  if (index < 0) {\n    index = url.indexOf('/about:blank', start);\n  }\n\n  // extract original url from wburl\n  if (index >= 0) {\n    url = url.substr(index + 1);\n  } else {\n    index = url.indexOf(this.wb_replay_prefix);\n    if (index >= 0) {\n      url = url.substr(index + this.wb_replay_prefix.length);\n    }\n    if (url.length > 4 && url.charAt(2) === '_' && url.charAt(3) === '/') {\n      url = url.substr(4);\n    }\n\n    if (\n      url !== rwURLString &&\n      !this.startsWithOneOf(url, this.VALID_PREFIXES) && !this.startsWith(url, 'blob:')\n    ) {\n      url = this.wb_orig_scheme + url;\n    }\n  }\n\n  if (\n    rwURLString.charAt(0) === '/' &&\n    rwURLString.charAt(1) !== '/' &&\n    this.startsWith(url, this.wb_orig_origin)\n  ) {\n    url = url.substr(this.wb_orig_origin.length);\n  }\n\n  if (this.startsWith(url, this.REL_PREFIX)) {\n    return this.wb_info.wombat_scheme + ':' + url;\n  }\n\n  return url;\n};\n\n/**\n * Creates and returns an A tag ready for parsing the original URL\n * part of the supplied URL.\n * @param {string} maybeRewrittenURL\n * @param {?Document} doc\n * @return {HTMLAnchorElement}\n */\nWombat.prototype.makeParser = function(maybeRewrittenURL, doc) {\n  var originalURL = this.extractOriginalURL(maybeRewrittenURL);\n  var docElem = doc;\n  if (!doc) {\n    // special case: for newly opened blank windows, use the opener\n    // to create parser to have the proper baseURI\n    if (\n      this.$wbwindow.location.href === 'about:blank' &&\n      this.$wbwindow.opener\n    ) {\n      docElem = this.$wbwindow.opener.document;\n    } else {\n      docElem = this.$wbwindow.document;\n    }\n  }\n\n  return this._makeURLParser(originalURL, docElem);\n\n};\n\nWombat.prototype._makeURLParser = function(url, docElem) {\n  try {\n    return new this.$wbwindow.URL(url, docElem.baseURI);\n  } catch (e) {}\n\n  var p = docElem.createElement('a');\n  p._no_rewrite = true;\n  p.href = url;\n  return p;\n};\n\n/**\n * Defines a new getter and optional setter for the property on the supplied\n * object returning T/F to indicate if the new property was successfully defined\n * @param {Object} obj\n * @param {string} prop\n * @param {?function(value: *): *} setFunc\n * @param {function(): *} getFunc\n * @param {?boolean} [enumerable]\n * @return {boolean}\n */\nWombat.prototype.defProp = function(obj, prop, setFunc, getFunc, enumerable) {\n  // if the property is marked as non-configurable in the current\n  // browser, skip the override\n  var existingDescriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  if (existingDescriptor && !existingDescriptor.configurable) {\n    return false;\n  }\n\n  // if no getter function was supplied, skip the override.\n  // See https://github.com/webrecorder/pywb/issues/147 for context\n  if (!getFunc) {\n    return false;\n  }\n\n  var descriptor = {\n    configurable: true,\n    enumerable: enumerable || false,\n    get: getFunc\n  };\n\n  if (setFunc) {\n    descriptor.set = setFunc;\n  }\n\n  try {\n    Object.defineProperty(obj, prop, descriptor);\n    return true;\n  } catch (e) {\n    console.warn('Failed to redefine property %s', prop, e.message);\n    return false;\n  }\n};\n\n/**\n * Defines a new getter for the property on the supplied object returning\n * T/F to indicate if the new property was successfully defined\n * @param {Object} obj\n * @param {string} prop\n * @param {function(): *} getFunc\n * @param {?boolean} [enumerable]\n * @return {boolean}\n */\nWombat.prototype.defGetterProp = function(obj, prop, getFunc, enumerable) {\n  var existingDescriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  if (existingDescriptor && !existingDescriptor.configurable) {\n    return false;\n  }\n  // if no getter function was supplied, skip the override.\n  // See https://github.com/webrecorder/pywb/issues/147 for context\n  if (!getFunc) return false;\n\n  try {\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      enumerable: enumerable || false,\n      get: getFunc\n    });\n    return true;\n  } catch (e) {\n    console.warn('Failed to redefine property %s', prop, e.message);\n    return false;\n  }\n};\n\n/**\n * Returns the original getter function for the supplied object's property\n * @param {Object} obj\n * @param {string} prop\n * @return {function(): *}\n */\nWombat.prototype.getOrigGetter = function(obj, prop) {\n  var orig_getter;\n\n  if (obj.__lookupGetter__) {\n    orig_getter = obj.__lookupGetter__(prop);\n  }\n\n  if (!orig_getter && Object.getOwnPropertyDescriptor) {\n    var props = Object.getOwnPropertyDescriptor(obj, prop);\n    if (props) {\n      orig_getter = props.get;\n    }\n  }\n\n  return orig_getter;\n};\n\n/**\n * Returns the original setter function for the supplied object's property\n * @param {Object} obj\n * @param {string} prop\n * @return {function(): *}\n */\nWombat.prototype.getOrigSetter = function(obj, prop) {\n  var orig_setter;\n\n  if (obj.__lookupSetter__) {\n    orig_setter = obj.__lookupSetter__(prop);\n  }\n\n  if (!orig_setter && Object.getOwnPropertyDescriptor) {\n    var props = Object.getOwnPropertyDescriptor(obj, prop);\n    if (props) {\n      orig_setter = props.set;\n    }\n  }\n\n  return orig_setter;\n};\n\n/**\n * Returns an array containing the names of all the properties\n * that exist on the supplied object\n * @param {Object} obj\n * @return {Array<string>}\n */\nWombat.prototype.getAllOwnProps = function(obj) {\n  /** @type {Array<string>} */\n  var ownProps = [];\n\n  var props = Object.getOwnPropertyNames(obj);\n  var i = 0;\n  for (; i < props.length; i++) {\n    var prop = props[i];\n\n    try {\n      if (obj[prop] && !obj[prop].prototype) {\n        ownProps.push(prop);\n      }\n    } catch (e) {}\n  }\n\n  var traverseObj = Object.getPrototypeOf(obj);\n\n  while (traverseObj) {\n    props = Object.getOwnPropertyNames(traverseObj);\n    for (i = 0; i < props.length; i++) {\n      ownProps.push(props[i]);\n    }\n    traverseObj = Object.getPrototypeOf(traverseObj);\n  }\n\n  return ownProps;\n};\n\n/**\n * Sends the supplied message to __WB_top_frame\n * @param {*} message\n * @param {boolean} [skipTopCheck]\n */\nWombat.prototype.sendTopMessage = function(message, skipTopCheck, win) {\n  win = win || this.$wbwindow;\n  if (!win.__WB_top_frame) return;\n  if (!skipTopCheck && win != win.__WB_replay_top) {\n    return;\n  }\n  win.__WB_top_frame.postMessage(message, this.wb_info.top_host);\n};\n\n/**\n * Notifies __WB_top_frame of an history update\n * @param {?string} url\n * @param {?string} title\n */\nWombat.prototype.sendHistoryUpdate = function(url, title, win) {\n  this.sendTopMessage(\n    {\n      url: url,\n      ts: this.wb_info.timestamp,\n      request_ts: this.wb_info.request_ts,\n      is_live: this.wb_info.is_live,\n      title: title,\n      wb_type: 'replace-url'\n    },\n    false,\n    win\n  );\n};\n\n/**\n * Updates the real location object with the results of rewriting the supplied URL\n * @param {?string} reqHref\n * @param {string} origHref\n * @param {Location} actualLocation\n */\nWombat.prototype.updateLocation = function(reqHref, origHref, actualLocation) {\n  if (!reqHref || reqHref === origHref) return;\n\n  var ext_orig = this.extractOriginalURL(origHref);\n  var ext_req = this.extractOriginalURL(reqHref);\n\n  if (!ext_orig || ext_orig === ext_req) return;\n\n  var final_href = this.rewriteUrl(reqHref);\n\n  console.log(actualLocation.href + ' -> ' + final_href);\n\n  actualLocation.href = final_href;\n};\n\n/**\n * Updates the real location with a change\n * @param {*} wombatLoc\n * @param {boolean} isTop\n */\nWombat.prototype.checkLocationChange = function(wombatLoc, isTop) {\n  var locType = typeof wombatLoc;\n\n  var actual_location = isTop\n    ? this.$wbwindow.__WB_replay_top.location\n    : this.$wbwindow.location;\n\n  // String has been assigned to location, so assign it\n  if (locType === 'string') {\n    this.updateLocation(wombatLoc, actual_location.href, actual_location);\n  } else if (locType === 'object') {\n    this.updateLocation(wombatLoc.href, wombatLoc._orig_href, actual_location);\n  }\n};\n\n/**\n * Checks for a location change, either this browser context or top and updates\n * accordingly\n * @return {boolean}\n */\nWombat.prototype.checkAllLocations = function() {\n  if (this.wb_wombat_updating) {\n    return false;\n  }\n\n  this.wb_wombat_updating = true;\n\n  this.checkLocationChange(this.$wbwindow.WB_wombat_location, false);\n\n  // Only check top if its a different $wbwindow\n  if (\n    this.$wbwindow.WB_wombat_location !=\n    this.$wbwindow.__WB_replay_top.WB_wombat_location\n  ) {\n    this.checkLocationChange(\n      this.$wbwindow.__WB_replay_top.WB_wombat_location,\n      true\n    );\n  }\n\n  this.wb_wombat_updating = false;\n};\n\n/**\n * Returns the Object the Proxy was proxying if it exists otherwise\n * the original object\n * @param {*} source\n * @return {?Object}\n */\nWombat.prototype.proxyToObj = function(source) {\n  if (source) {\n    try {\n      var proxyRealObj = source.__WBProxyRealObj__;\n      if (proxyRealObj) return proxyRealObj;\n    } catch (e) {}\n  }\n  return source;\n};\n\n/**\n * Returns the Proxy object for the supplied Object if it exists otherwise\n * the original object\n * @param {?Object} obj\n * @return {Proxy|?Object}\n */\nWombat.prototype.objToProxy = function(obj) {\n  if (obj) {\n    try {\n      var maybeWbProxy = obj._WB_wombat_obj_proxy;\n      if (maybeWbProxy) return maybeWbProxy;\n    } catch (e) {}\n  }\n  return obj;\n};\n\n/**\n * Returns the value of supplied object that is being Proxied\n * @param {*} obj\n * @param {*} prop\n * @param {Array<string>} ownProps\n * @param {Object} fnCache\n * @return {*}\n */\nWombat.prototype.defaultProxyGet = function(obj, prop, ownProps, fnCache) {\n  switch (prop) {\n    case '__WBProxyRealObj__':\n      return obj;\n    case 'location':\n    case 'WB_wombat_location':\n      return obj.WB_wombat_location;\n    case '_WB_wombat_obj_proxy':\n      return obj._WB_wombat_obj_proxy;\n    case '__WB_pmw':\n    case this.WB_ASSIGN_FUNC:\n    case this.WB_CHECK_THIS_FUNC:\n      return obj[prop];\n\n    case 'origin':\n      return obj.WB_wombat_location.origin;\n\n    case 'constructor':\n      // allow tests that check constructor name/equality to work\n      // you can't create a new instance of window, document or location using the constructors\n      return obj.constructor;\n  }\n  var retVal = obj[prop];\n\n  var type = typeof retVal;\n\n  if (type === 'function' && ownProps.indexOf(prop) !== -1) {\n    // certain sites (e.g. facebook) are applying polyfills to native functions\n    // treating the polyfill as a native function [fn.bind(obj)] causes incorrect execution of the polyfill\n    // also depending on the site, the site can detect we \"tampered\" with the polyfill by binding it to obj\n    // to avoid these situations, we do not bind the returned fn if we detect they were polyfilled\n    switch (prop) {\n      case 'requestAnimationFrame':\n      case 'cancelAnimationFrame': {\n        if (!this.isNativeFunction(retVal)) {\n          return retVal;\n        }\n        break;\n      }\n\n      case 'eval':\n        if (this.isNativeFunction(retVal)) {\n          return this.wrappedEval(retVal);\n        }\n        break;\n    }\n    // due to specific use cases involving native functions\n    // we must return the\n    var cachedFN = fnCache[prop];\n    if (!cachedFN || cachedFN.original !== retVal) {\n      cachedFN = {\n        original: retVal,\n        boundFn: retVal.bind(obj)\n      };\n      fnCache[prop] = cachedFN;\n    }\n    return cachedFN.boundFn;\n  } else if (type === 'object' && retVal && retVal._WB_wombat_obj_proxy) {\n    if (retVal instanceof this.WBWindow) {\n      this.initNewWindowWombat(retVal);\n    }\n    return retVal._WB_wombat_obj_proxy;\n  }\n\n  return retVal;\n};\n\n/**\n * Set the location properties for either an instance of WombatLocation\n * or an anchor tag\n * @param {HTMLAnchorElement|WombatLocation} loc\n * @param {string} originalURL\n */\nWombat.prototype.setLoc = function(loc, originalURL) {\n  var parser = this.makeParser(originalURL, loc.ownerDocument);\n\n  loc._orig_href = originalURL;\n  loc._parser = parser;\n\n  var href = parser.href;\n  loc._hash = parser.hash;\n\n  loc._href = href;\n\n  loc._host = parser.host;\n  loc._hostname = parser.hostname;\n\n  if (parser.origin) {\n    loc._origin = parser.host ? parser.origin : 'null';\n  } else {\n    loc._origin =\n      parser.protocol +\n      '//' +\n      parser.hostname +\n      (parser.port ? ':' + parser.port : '');\n  }\n\n  loc._pathname = parser.pathname;\n  loc._port = parser.port;\n  // this.protocol = parser.protocol;\n  loc._protocol = parser.protocol;\n  loc._search = parser.search;\n\n  if (!Object.defineProperty) {\n    loc.href = href;\n    loc.hash = parser.hash;\n\n    loc.host = loc._host;\n    loc.hostname = loc._hostname;\n    loc.origin = loc._origin;\n    loc.pathname = loc._pathname;\n    loc.port = loc._port;\n    loc.protocol = loc._protocol;\n    loc.search = loc._search;\n  }\n};\n\n/**\n * Returns a function for retrieving some property on an instance of either\n * WombatLocation or an anchor tag\n * @param {string} prop\n * @param {function(): string} origGetter\n * @return {function(): string}\n */\nWombat.prototype.makeGetLocProp = function(prop, origGetter) {\n  var wombat = this;\n  return function newGetLocProp() {\n    if (this._no_rewrite) return origGetter.call(this, prop);\n\n    var curr_orig_href = origGetter.call(this, 'href');\n\n    if (prop === 'href') {\n      return wombat.extractOriginalURL(curr_orig_href);\n    }\n\n    if (prop === 'ancestorOrigins') {\n      return [];\n    }\n\n    if (this._orig_href !== curr_orig_href) {\n      wombat.setLoc(this, curr_orig_href);\n    }\n    return this['_' + prop];\n  };\n};\n\n/**\n * Returns a function for setting some property on an instance of either\n * WombatLocation or an anchor tag\n * @param {string} prop\n * @param {function (value: *): *} origSetter\n * @param {function(): *} origGetter\n * @return {function (value: *): *}\n */\nWombat.prototype.makeSetLocProp = function(prop, origSetter, origGetter) {\n  var wombat = this;\n  return function newSetLocProp(value) {\n    if (this._no_rewrite) {\n      return origSetter.call(this, prop, value);\n    }\n    if (this['_' + prop] === value) return;\n\n    this['_' + prop] = value;\n\n    var href = origGetter.call(this);\n    var parser = wombat.makeParser(href, this.ownerDocument);\n\n    var rel = false;\n\n    // Special case for assigning href to a relative path\n    if (prop === 'href' && typeof value === 'string') {\n      if (value && parser instanceof URL) {\n        try {\n          value = new URL(value, parser).href;\n        } catch (e) {\n          console.warn('Error resolving URL', e);\n        }\n      } else if (value) {\n        if (value[0] === '.' || value[0] === '#') {\n          value = wombat.resolveRelUrl(value, this.ownerDocument);\n        } else if (value[0] === '/') {\n          if (value.length > 1 && value[1] === '/') {\n            value = parser.protocol + value;\n          } else {\n            rel = true;\n            value = WB_wombat_location.origin + value;\n          }\n        }\n      }\n    }\n\n    try {\n      parser[prop] = value;\n    } catch (e) {\n      console.log('Error setting ' + prop + ' = ' + value);\n    }\n\n    if (prop === 'hash') {\n      value = parser[prop];\n      origSetter.call(this, 'hash', value);\n    } else {\n      rel = rel || value === parser.pathname;\n      value = wombat.rewriteUrl(parser.href, rel);\n      origSetter.call(this, 'href', value);\n    }\n  };\n};\n\n/**\n * Function used for rewriting URL's contained in CSS style definitions\n * @param {Object} match\n * @param {string} n1\n * @param {string} n2\n * @param {string} n3\n * @param {number} offset\n * @param {string} string\n * @return {string}\n */\nWombat.prototype.styleReplacer = function(match, n1, n2, n3, offset, string) {\n  return n1 + this.rewriteUrl(n2) + n3;\n};\n\n\n/**\n * Due to the fact that we override specific DOM constructors, e.g. Worker,\n * the normal TypeErrors are not thrown if the pre-conditions for those\n * constructors are not met.\n *\n * Code that performs polyfills or browser feature detection based\n * on those TypeErrors will not work as expected if we do not perform\n * those checks ourselves (Note we use Chrome's error messages)\n *\n * This function checks for those pre-conditions and throws an TypeError\n * with the appropriate message if a pre-condition is not met\n *  - `this` instanceof Window is false (requires new)\n *  - supplied required arguments\n *\n * @param {Object} thisObj\n * @param {string} what\n * @param {Object} [args]\n * @param {number} [numRequiredArgs]\n */\nWombat.prototype.domConstructorErrorChecker = function(\n  thisObj,\n  what,\n  args,\n  numRequiredArgs\n) {\n  var needArgs = typeof numRequiredArgs === 'number' ? numRequiredArgs : 1;\n  var errorMsg;\n  if (thisObj instanceof this.WBWindow) {\n    errorMsg =\n      'Failed to construct \\'' +\n      what +\n      '\\': Please use the \\'new\\' operator, this DOM object constructor cannot be called as a function.';\n  } else if (args && args.length < needArgs) {\n    errorMsg =\n      'Failed to construct \\'' +\n      what +\n      '\\': ' +\n      needArgs +\n      ' argument required, but only 0 present.';\n  }\n  if (errorMsg) {\n    throw new TypeError(errorMsg);\n  }\n};\n\n/**\n * Rewrites the arguments supplied to an function of the Node interface\n * @param {Object} fnThis\n * @param {function} originalFn\n * @param {Node} newNode\n * @param {Node} [oldNode]\n */\nWombat.prototype.rewriteNodeFuncArgs = function(\n  fnThis,\n  originalFn,\n  newNode,\n  oldNode\n) {\n  if (newNode) {\n    switch (newNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        this.rewriteElemComplete(newNode);\n        break;\n      case Node.TEXT_NODE:\n        // newNode is the new child of fnThis (the parent node)\n        if (\n          fnThis.tagName === 'STYLE' ||\n          (newNode.parentNode && newNode.parentNode.tagName === 'STYLE')\n        ) {\n          newNode.textContent = this.rewriteStyle(newNode.textContent);\n        }\n        break;\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        this.recurseRewriteElem(newNode);\n        break;\n    }\n  }\n  var created = originalFn.call(fnThis, newNode, oldNode);\n  if (created && created.tagName === 'IFRAME') {\n    created.allow = 'autoplay \\'self\\'; fullscreen \\'self\\'';\n    this.initIframeWombat(created);\n  }\n  return created;\n};\n\n/**\n * Mini url rewriter specifically for rewriting web sockets\n * @param {?string} originalURL\n * @return {string}\n */\nWombat.prototype.rewriteWSURL = function(originalURL) {\n  // If undefined, just return it\n  if (!originalURL) return originalURL;\n\n  var urltype_ = typeof originalURL;\n  var url = originalURL;\n\n  // If object, use toString\n  if (urltype_ === 'object') {\n    url = originalURL.toString();\n  } else if (urltype_ !== 'string') {\n    return originalURL;\n  }\n\n  // empty string check\n  if (!url) return url;\n\n  var wsScheme = 'ws://';\n  var wssScheme = 'wss://';\n\n  // proxy mode: If no wb_replay_prefix, only rewrite scheme\n  // proxy mode: If no wb_replay_prefix, only rewrite scheme\n  if (this.wb_is_proxy) {\n    if (\n      this.wb_orig_scheme === this.HTTP_PREFIX &&\n      this.startsWith(url, wssScheme)\n    ) {\n      return wsScheme + url.substr(wssScheme.length);\n    } else if (\n      this.wb_orig_scheme === this.HTTPS_PREFIX &&\n      this.startsWith(url, wsScheme)\n    ) {\n      return wssScheme + url.substr(wsScheme.length);\n    } else {\n      return url;\n    }\n  }\n\n  var wbSecure = this.wb_abs_prefix.indexOf(this.HTTPS_PREFIX) === 0;\n  var wbPrefix = this.wb_abs_prefix.replace(\n    wbSecure ? this.HTTPS_PREFIX : this.HTTP_PREFIX,\n    wbSecure ? wssScheme : wsScheme\n  );\n  wbPrefix += this.wb_info.wombat_ts + 'ws_';\n  if (url[url.length - 1] !== '/') {\n    wbPrefix += '/';\n  }\n  return wbPrefix + url.replace('WB_wombat_', '');\n};\n\n/**\n * Rewrites the supplied URL returning the rewritten URL\n * @param {?string} originalURL\n * @param {?boolean} [useRel]\n * @param {?string} [mod]\n * @param {?Document} [doc]\n * @return {?string}\n * @private\n */\nWombat.prototype.rewriteUrl_ = function(originalURL, useRel, mod, doc) {\n  // If undefined, just return it\n  if (!originalURL) return originalURL;\n\n  var urltype_ = typeof originalURL;\n  var url;\n\n  // If object, use toString\n  if (urltype_ === 'object') {\n    url = originalURL.toString();\n  } else if (urltype_ !== 'string') {\n    return originalURL;\n  } else {\n    url = originalURL;\n  }\n\n  // empty string check\n  if (!url) return url;\n\n  // proxy mode: If no wb_replay_prefix, only rewrite scheme\n  if (this.wb_is_proxy) {\n    if (\n      this.wb_orig_scheme === this.HTTP_PREFIX &&\n      this.startsWith(url, this.HTTPS_PREFIX)\n    ) {\n      return this.HTTP_PREFIX + url.substr(this.HTTPS_PREFIX.length);\n    } else if (\n      this.wb_orig_scheme === this.HTTPS_PREFIX &&\n      this.startsWith(url, this.HTTP_PREFIX)\n    ) {\n      return this.HTTPS_PREFIX + url.substr(this.HTTP_PREFIX.length);\n    } else {\n      return url;\n    }\n  }\n\n  // just in case _wombat reference made it into url!\n  url = url.replace('WB_wombat_', '');\n\n  if (mod === 'if_' && this.wb_info.isSW && this.startsWith(url, 'blob:')) {\n    return this.wb_info.prefix + this.wb_info.request_ts + 'if_/' + url;\n  }\n\n  // ignore anchors, about, data\n  if (this.startsWithOneOf(url.toLowerCase(), this.IGNORE_PREFIXES)) {\n    return url;\n  }\n\n  // OPTS: additional ignore prefixes\n  if (\n    this.wb_opts.no_rewrite_prefixes &&\n    this.startsWithOneOf(url, this.wb_opts.no_rewrite_prefixes)\n  ) {\n    return url;\n  }\n\n  // If starts with prefix, no rewriting needed\n  // Only check replay prefix (no date) as date may be different for each\n  // capture\n\n  // if scheme relative, prepend current scheme\n  var check_url;\n\n  if (url.indexOf('//') === 0) {\n    check_url = this.origProtocol + url;\n  } else {\n    check_url = url;\n  }\n\n  //var originalLoc = this.$wbwindow.location;\n  if (\n    this.startsWith(check_url, this.wb_abs_prefix) ||\n    this.startsWith(check_url, this.wb_rel_prefix)\n  ) {\n    return url;\n  }\n\n  // A special case where the port somehow gets dropped\n  // Check for this and add it back in, eg http://localhost/path/ -> http://localhost:8080/path/\n  if (\n    this.origHost !== this.origHostname &&\n    this.startsWith(\n      url,\n      this.origProtocol + '//' + this.origHostname + '/'\n    )\n  ) {\n    return url.replace(\n      '/' + this.origHostname + '/',\n      '/' + this.origHost + '/'\n    );\n  }\n\n  // If server relative url, add prefix and original host\n  if (url.charAt(0) === '/' && !this.startsWith(url, this.REL_PREFIX)) {\n    // Already a relative url, don't make any changes!\n    if (\n      this.wb_capture_date_part &&\n      url.indexOf(this.wb_capture_date_part) >= 0\n    ) {\n      return url;\n    }\n\n    // relative collection\n    if (url.indexOf(this.wb_rel_prefix) === 0 && url.indexOf('http') > 1) {\n      var scheme_sep = url.indexOf(':/');\n      if (scheme_sep > 0 && url[scheme_sep + 2] !== '/') {\n        return (\n          url.substring(0, scheme_sep + 2) + '/' + url.substring(scheme_sep + 2)\n        );\n      }\n      return url;\n    }\n\n    return this.getFinalUrl(true, mod, this.wb_orig_origin + url);\n  }\n\n  // Use a parser\n  if (url.charAt(0) === '.') {\n    url = this.resolveRelUrl(url, doc);\n  }\n\n  // If full url starting with http://, https:// or //\n  // add rewrite prefix, we convert to lower case for this check\n  // due to the fact that the URL's scheme could be HTTP(S) LUL\n  var prefix = this.startsWithOneOf(url.toLowerCase(), this.VALID_PREFIXES);\n\n  if (prefix) {\n    //var orig_host = this.$wbwindow.__WB_replay_top.location.host;\n    //var orig_protocol = this.$wbwindow.__WB_replay_top.location.protocol;\n    var orig_host = this.replayTopHost;\n    var orig_protocol = this.replayTopProtocol;\n\n    var prefix_host = prefix + orig_host + '/';\n\n    // if already rewritten url, must still check scheme\n    if (this.startsWith(url, prefix_host)) {\n      if (this.startsWith(url, this.wb_replay_prefix)) {\n        return url;\n      }\n\n      var curr_scheme = orig_protocol + '//';\n      var path = url.substring(prefix_host.length);\n      var rebuild = false;\n\n      if (path.indexOf(this.wb_rel_prefix) < 0 && url.indexOf('/static/') < 0) {\n        path = this.getFinalUrl(\n          true,\n          mod,\n          WB_wombat_location.origin + '/' + path\n        );\n        rebuild = true;\n      }\n\n      // replace scheme to ensure using the correct server scheme\n      // if (starts_with(url, wb_orig_scheme) && (wb_orig_scheme != curr_scheme)) {\n      if (prefix !== curr_scheme && prefix !== this.REL_PREFIX) {\n        rebuild = true;\n      }\n\n      if (rebuild) {\n        if (!useRel) {\n          url = curr_scheme + orig_host;\n        } else {\n          url = '';\n        }\n        if (path && path[0] !== '/') {\n          url += '/';\n        }\n        url += path;\n      }\n\n      return url;\n    }\n    return this.getFinalUrl(useRel, mod, url);\n  }\n  // Check for common bad prefixes and remove them\n  prefix = this.startsWithOneOf(url, this.BAD_PREFIXES);\n\n  if (prefix) {\n    return this.getFinalUrl(useRel, mod, this.extractOriginalURL(url));\n  }\n\n  // May or may not be a hostname, call function to determine\n  // If it is, add the prefix and make sure port is removed\n  //if (this.isHostUrl(url) && !this.startsWith(url, originalLoc.host + '/')) {\n  //  return this.getFinalUrl(useRel, mod, this.wb_orig_scheme + url);\n  //}\n\n  return url;\n};\n\n/**\n * Rewrites the supplied URL returning the rewritten URL.\n * If wombat is in debug mode the rewrite is logged to the console\n * @param {*} url\n * @param {?boolean} [useRel]\n * @param {?string} [mod]\n * @param {?Document} [doc]\n * @return {?string}\n */\nWombat.prototype.rewriteUrl = function(url, useRel, mod, doc) {\n  var rewritten = this.rewriteUrl_(url, useRel, mod, doc);\n  if (this.debug_rw) {\n    if (url !== rewritten) {\n      console.log('REWRITE: ' + url + ' -> ' + rewritten);\n    } else {\n      console.log('NOT REWRITTEN ' + url);\n    }\n  }\n  return rewritten;\n};\n\n/**\n * Rewrites the value of the supplied elements attribute returning its rewritten value.\n * Used by {@link newAttrObjGetSet} and {@link rewriteAttr}\n *\n * @param {Element} elem\n * @param {string} name\n * @param {*} value\n * @param {boolean} [absUrlOnly]\n * @return {*}\n */\nWombat.prototype.performAttributeRewrite = function(\n  elem,\n  name,\n  value,\n  absUrlOnly\n) {\n  switch (name) {\n    // inner and outer HTML are for the overrides applied by newAttrObjGetSet\n    case 'innerHTML':\n    case 'outerHTML':\n      return this.rewriteHtml(value);\n    case 'filter': // for svg filter attribute which is url(...)\n      return this.rewriteInlineStyle(value);\n    case 'style':\n      return this.rewriteStyle(value);\n    case 'srcset':\n      return this.rewriteSrcset(value, elem);\n  }\n  // Only rewrite if absolute url\n  if (absUrlOnly && !this.startsWithOneOf(value, this.VALID_PREFIXES)) {\n    return value;\n  }\n  var mod = this.rwModForElement(elem, name);\n  if (\n    this.wbUseAFWorker &&\n    this.WBAutoFetchWorker &&\n    this.isSavedDataSrcSrcset(elem)\n  ) {\n    this.WBAutoFetchWorker.preserveDataSrcset(elem);\n  }\n  return this.rewriteUrl(value, false, mod, elem.ownerDocument);\n};\n\n/**\n * Rewrites an element attribute's value\n * @param {Element} elem\n * @param {string} name\n * @param {boolean} [absUrlOnly]\n * @return {boolean}\n */\nWombat.prototype.rewriteAttr = function(elem, name, absUrlOnly) {\n  var changed = false;\n  if (!elem || !elem.getAttribute || elem._no_rewrite || elem['_' + name]) {\n    return changed;\n  }\n\n  var value = this.wb_getAttribute.call(elem, name);\n\n  if (!value || this.startsWith(value, 'javascript:')) return changed;\n\n  var new_value = this.performAttributeRewrite(elem, name, value, absUrlOnly);\n\n  if (new_value !== value) {\n    this.removeWBOSRC(elem);\n    this.wb_setAttribute.call(elem, name, new_value);\n    changed = true;\n  }\n\n  return changed;\n};\n\n/**\n * {@link rewriteStyle} wrapped in a try catch\n * @param {string|Object} style\n * @return {string|Object|null}\n */\nWombat.prototype.noExceptRewriteStyle = function(style) {\n  try {\n    return this.rewriteStyle(style);\n  } catch (e) {\n    return style;\n  }\n};\n\n/**\n * Rewrites the supplied CSS style definitions\n * @param {string|Object} style\n * @return {string|Object|null}\n */\nWombat.prototype.rewriteStyle = function(style) {\n  if (!style) return style;\n\n  var value = style;\n  if (typeof style === 'object') {\n    value = style.toString();\n  }\n\n  if (typeof value === 'string') {\n    return value\n      .replace(this.STYLE_REGEX, this.styleReplacer)\n      .replace(this.IMPORT_REGEX, this.styleReplacer)\n      .replace(this.no_wombatRe, '');\n  }\n\n  return value;\n};\n\n/**\n * Rewrites the supplied srcset string returning the rewritten results.\n * If the element is one the srcset values are auto-fetched they are sent\n * to the backing auto-fetch worker\n * @param {string} value\n * @param {Element} elem\n * @return {string}\n */\nWombat.prototype.rewriteSrcset = function(value, elem) {\n  if (!value) return '';\n\n  var split = value.split(this.srcsetRe);\n  var values = [];\n  var mod = this.rwModForElement(elem, 'srcset');\n  for (var i = 0; i < split.length; i++) {\n    // Filter removes non-truthy values like null, undefined, and \"\"\n    var v = split[i];\n    if (v) {\n      var parts = v.trim().split(' ');\n      parts[0] = this.rewriteUrl(parts[0], true, mod);\n      values.push(parts.join(' '));\n    }\n  }\n\n  if (\n    this.wbUseAFWorker &&\n    this.WBAutoFetchWorker &&\n    this.isSavedSrcSrcset(elem)\n  ) {\n    // send post split values to preservation worker\n    this.WBAutoFetchWorker.preserveSrcset(\n      values,\n      this.WBAutoFetchWorker.rwMod(elem)\n    );\n  }\n\n  return values.join(', ');\n};\n\n/**\n * Rewrites the URL supplied to the setter of an (i)frame's src attribute\n * @param {Element} elem\n * @param {string} attrName\n * @return {boolean}\n */\nWombat.prototype.rewriteFrameSrc = function(elem, attrName) {\n  var value = this.wb_getAttribute.call(elem, attrName);\n  var new_value;\n\n  // special case for rewriting javascript: urls that contain WB_wombat_\n  // must insert _wombat init first!\n  if (this.startsWith(value, 'javascript:')) {\n    if (value.indexOf('WB_wombat_') >= 0) {\n      var JS = 'javascript:';\n      new_value =\n        JS +\n        'window.parent._wb_wombat.initNewWindowWombat(window);' +\n        value.substr(JS.length);\n    }\n  }\n\n  if (!new_value) {\n    new_value = this.rewriteUrl(\n      value,\n      false,\n      this.rwModForElement(elem, attrName)\n    );\n  }\n\n  if (new_value !== value) {\n    this.wb_setAttribute.call(elem, attrName, new_value);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Rewrites either the URL contained in the src attribute or the text contents\n * of the supplied script element. Returns T/F indicating if a rewrite occurred\n * @param elem\n * @return {boolean}\n */\nWombat.prototype.rewriteScript = function(elem) {\n  if (elem.hasAttribute('src') || !elem.textContent || !this.$wbwindow.Proxy) {\n    return this.rewriteAttr(elem, 'src');\n  }\n  if (this.skipWrapScriptBasedOnType(elem.type)) return false;\n  var text = elem.textContent.trim();\n  if (this.skipWrapScriptTextBasedOnText(text)) return false;\n  elem.textContent = this.wrapScriptTextJsProxy(text);\n  if (this.wb_info.injectDocClose && elem.textContent.trim().length) {\n    elem.textContent += ';document.close();';\n  }\n  return true;\n};\n\n/**\n * Rewrites the supplied SVG element returning T/F indicating if a rewrite occurred\n * @param {SVGElement} elem\n * @return {boolean}\n */\nWombat.prototype.rewriteSVGElem = function(elem) {\n  var changed = this.rewriteAttr(elem, 'filter');\n  changed = this.rewriteAttr(elem, 'style') || changed;\n  // xlink:href is deprecated since SVG 2 in favor of href\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href\n  changed = this.rewriteAttr(elem, 'xlink:href') || changed;\n  changed = this.rewriteAttr(elem, 'href') || changed;\n  changed = this.rewriteAttr(elem, 'src') || changed;\n  return changed;\n};\n\n/**\n * Rewrites the supplied element returning T/F indicating if a rewrite occurred\n * @param {Element|Node} elem - The element to be rewritten\n * @return {boolean}\n */\nWombat.prototype.rewriteElem = function(elem) {\n  var changed = false;\n  if (!elem) return changed;\n  if (elem instanceof SVGElement) {\n    changed = this.rewriteSVGElem(elem);\n  } else {\n    switch (elem.tagName) {\n      case 'META':\n        var maybeCSP = this.wb_getAttribute.call(elem, 'http-equiv');\n        if (maybeCSP && maybeCSP.toLowerCase() === 'content-security-policy') {\n          this.wb_setAttribute.call(elem, 'http-equiv', '_' + maybeCSP);\n          changed = true;\n        }\n        break;\n      case 'STYLE':\n        var new_content = this.rewriteStyle(elem.textContent);\n        if (elem.textContent !== new_content) {\n          elem.textContent = new_content;\n          changed = true;\n          if (\n            this.wbUseAFWorker &&\n            this.WBAutoFetchWorker &&\n            elem.sheet != null\n          ) {\n            // we have a stylesheet so lets be nice to UI thread\n            // and defer extraction\n            this.WBAutoFetchWorker.deferredSheetExtraction(elem.sheet);\n          }\n        }\n        break;\n      case 'LINK':\n        changed = this.rewriteAttr(elem, 'href');\n        if (this.wbUseAFWorker && elem.rel === 'stylesheet') {\n          // we can only check link[rel='stylesheet'] when it loads\n          this._addEventListener(\n            elem,\n            'load',\n            this.utilFns.wbSheetMediaQChecker\n          );\n        }\n        break;\n      case 'IMG':\n        changed = this.rewriteAttr(elem, 'src');\n        changed = this.rewriteAttr(elem, 'srcset') || changed;\n        changed = this.rewriteAttr(elem, 'style') || changed;\n        if (\n          this.wbUseAFWorker &&\n          this.WBAutoFetchWorker &&\n          elem.dataset.srcset\n        ) {\n          this.WBAutoFetchWorker.preserveDataSrcset(elem);\n        }\n        break;\n      case 'OBJECT':\n        if (this.wb_info.isSW && elem.parentElement && elem.getAttribute('type') === 'application/pdf') {\n          var iframe = this.$wbwindow.document.createElement('IFRAME');\n          for (var i = 0; i < elem.attributes.length; i++) {\n            var attr = elem.attributes[i];\n            var name = attr.name;\n            if (name === 'data') {\n              name = 'src';\n            }\n            this.wb_setAttribute.call(iframe, name, attr.value);\n          }\n\n          elem.parentElement.replaceChild(iframe, elem);\n          changed = true;\n          break;\n        }\n\n        changed = this.rewriteAttr(elem, 'data', true);\n        changed = this.rewriteAttr(elem, 'style') || changed;\n        break;\n      case 'FORM':\n        changed = this.rewriteAttr(elem, 'poster');\n        changed = this.rewriteAttr(elem, 'action') || changed;\n        changed = this.rewriteAttr(elem, 'style') || changed;\n        break;\n      case 'IFRAME':\n        changed = this.rewriteFrameSrc(elem, 'src');\n        if (this.wb_info.isSW && !changed) {\n          var srcdoc = elem.getAttribute('srcdoc');\n          if (elem.hasAttribute('srcdoc')) {\n            elem.removeAttribute('srcdoc');\n          }\n          if (srcdoc) {\n            this.blobUrlForIframe(elem, srcdoc);\n          } else {\n            var src = elem.getAttribute('src');\n            if (!src || src === 'about:blank') {\n              if (!src) {\n                elem.__WB_blank = true;\n              }\n              elem.src = this.wb_info.prefix + this.wb_info.request_ts + 'mp_/about:blank';\n            }\n          }\n        }\n        changed = this.rewriteAttr(elem, 'style') || changed;\n        break;\n      case 'FRAME':\n        changed = this.rewriteFrameSrc(elem, 'src');\n        changed = this.rewriteAttr(elem, 'style') || changed;\n        break;\n      case 'SCRIPT':\n        changed = this.rewriteScript(elem);\n        break;\n      case 'A':\n        changed = this.rewriteAttr(elem, 'href') || changed;\n        if (elem.hasAttribute('target')) {\n          var newTarget = this.rewriteAttrTarget(elem.target);\n          if (newTarget !== elem.target) {\n            elem.target = newTarget;\n            changed = true;\n          }\n        }\n        break;\n\n      default: {\n        changed = this.rewriteAttr(elem, 'src');\n        changed = this.rewriteAttr(elem, 'srcset') || changed;\n        changed = this.rewriteAttr(elem, 'href') || changed;\n        changed = this.rewriteAttr(elem, 'style') || changed;\n        changed = this.rewriteAttr(elem, 'poster') || changed;\n        break;\n      }\n    }\n  }\n\n  if (elem.hasAttribute && elem.removeAttribute) {\n    if (elem.hasAttribute('crossorigin')) {\n      elem.removeAttribute('crossorigin');\n      changed = true;\n    }\n\n    if (elem.hasAttribute('integrity')) {\n      elem.removeAttribute('integrity');\n      changed = true;\n    }\n  }\n  return changed;\n};\n\n/**\n * Rewrites all the children and there descendants of the supplied Node\n * returning T/F if a rewrite occurred\n * @param {Node} curr\n * @return {boolean}\n */\nWombat.prototype.recurseRewriteElem = function(curr) {\n  if (!this.nodeHasChildren(curr)) return false;\n  var changed = false;\n  var rewriteQ = [curr.children || curr.childNodes];\n\n  while (rewriteQ.length > 0) {\n    var children = rewriteQ.shift();\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        changed = this.rewriteElem(child) || changed;\n        if (this.nodeHasChildren(child)) {\n          rewriteQ.push(child.children || child.childNodes);\n        }\n      }\n    }\n  }\n\n  return changed;\n};\n\n/**\n * Rewrites the supplied element and all its children if any.\n * See {@link rewriteElem} and {@link recurseRewriteElem} for more details\n * @param {Node} elem\n * @return {boolean}\n */\nWombat.prototype.rewriteElemComplete = function(elem) {\n  if (!elem) return false;\n  var changed = this.rewriteElem(elem);\n  var changedRecursively = this.recurseRewriteElem(elem);\n  return changed || changedRecursively;\n};\n\n/**\n * Rewrites any elements found in the supplied arguments object returning\n * a new array containing the original contents of the supplied arguments\n * object after rewriting.\n * @param {Object} originalArguments\n * @return {Array<*>}\n */\nWombat.prototype.rewriteElementsInArguments = function(originalArguments) {\n  var argArr = new Array(originalArguments.length);\n  for (var i = 0; i < originalArguments.length; i++) {\n    var argElem = originalArguments[i];\n    if (argElem instanceof Node) {\n      this.rewriteElemComplete(argElem);\n      argArr[i] = argElem;\n    } else if (typeof argElem === 'string') {\n      argArr[i] = this.rewriteHtml(argElem);\n    } else {\n      argArr[i] = argElem;\n    }\n  }\n  return argArr;\n};\n\n/**\n * Rewrites the supplied string containing HTML, if the supplied string\n * is full HTML (starts with <HTML, <DOCUMENT...) the string is rewritten\n * using {@link Wombat#rewriteHtmlFull}\n * @param {string} string\n * @param {boolean} [checkEndTag]\n * @return {?string}\n */\nWombat.prototype.rewriteHtml = function(string, checkEndTag) {\n  if (!string) {\n    return string;\n  }\n  var rwString = string;\n  if (typeof string !== 'string') {\n    rwString = string.toString();\n  }\n\n  if (this.write_buff) {\n    rwString = this.write_buff + rwString;\n    this.write_buff = '';\n  }\n\n  if (rwString.indexOf('<script') <= 0) {\n    // string = string.replace(/WB_wombat_/g, \"\");\n    rwString = rwString.replace(/((id|class)=\".*)WB_wombat_([^\"]+)/, '$1$3');\n  }\n\n  if (\n    !this.$wbwindow.HTMLTemplateElement ||\n    this.FullHTMLRegex.test(rwString)\n  ) {\n    return this.rewriteHtmlFull(rwString, checkEndTag);\n  }\n\n  var inner_doc = new DOMParser().parseFromString(\n    '<template>' + rwString + '</template>',\n    'text/html'\n  );\n\n  if (\n    !inner_doc ||\n    !this.nodeHasChildren(inner_doc.head) ||\n    !inner_doc.head.children[0].content\n  ) {\n    return rwString;\n  }\n\n  var template = inner_doc.head.children[0];\n  template._no_rewrite = true;\n  if (this.recurseRewriteElem(template.content)) {\n    var new_html = template.innerHTML;\n    if (checkEndTag) {\n      var first_elem =\n        template.content.children && template.content.children[0];\n      if (first_elem) {\n        var end_tag = '</' + first_elem.tagName.toLowerCase() + '>';\n        // check if new_html has an extra ending tag while original did not\n        // eg. <div>... rewritten to </div>, then we strip out the ending tag\n        if (\n          this.endsWith(new_html, end_tag) &&\n          !this.endsWith(rwString.toLowerCase(), end_tag)\n        ) {\n          new_html = new_html.substring(0, new_html.length - end_tag.length);\n        // similarly, check if original had extra ending tags that rewritten did not\n        // eg. <a>...</a></div> rewritten to <a>...</a>, then we add the remaining </div>\n        // currently only works with different tags\n        } else if (new_html.trimEnd().endsWith(end_tag) && !rwString.trimEnd().endsWith(end_tag)) {\n          var lastInx = rwString.lastIndexOf(end_tag);\n          if (lastInx > 0) {\n            new_html += rwString.slice(lastInx + end_tag.length);\n          }\n        }\n      } else if (rwString[0] !== '<' || rwString[rwString.length - 1] !== '>') {\n        this.write_buff += rwString;\n        return undefined;\n      }\n    }\n    return new_html;\n  }\n\n  return rwString;\n};\n\n/**\n * Rewrites the supplied string containing full HTML\n * @param {string} string\n * @param {boolean} [checkEndTag]\n * @return {?string}\n */\nWombat.prototype.rewriteHtmlFull = function(string, checkEndTag) {\n  var inner_doc = new DOMParser().parseFromString(string, 'text/html');\n  if (!inner_doc) return string;\n\n  var changed = false;\n\n  for (var i = 0; i < inner_doc.all.length; i++) {\n    changed = this.rewriteElem(inner_doc.all[i]) || changed;\n  }\n\n  if (changed) {\n    var new_html;\n    // if original had <html> tag, add full document HTML\n    if (string && string.indexOf('<html') >= 0) {\n      inner_doc.documentElement._no_rewrite = true;\n      new_html =\n        this.reconstructDocType(inner_doc.doctype) +\n        inner_doc.documentElement.outerHTML;\n    } else {\n      //\n      inner_doc.head._no_rewrite = true;\n      inner_doc.body._no_rewrite = true;\n      // hasChildNodes includes text nodes\n      var headHasKids = this.nodeHasChildren(inner_doc.head);\n      var bodyHasKids = this.nodeHasChildren(inner_doc.body);\n      new_html =\n        (headHasKids ? inner_doc.head.outerHTML : '') +\n        (bodyHasKids ? inner_doc.body.outerHTML : '');\n      if (checkEndTag) {\n        if (inner_doc.all.length > 3) {\n          var end_tag = '</' + inner_doc.all[3].tagName.toLowerCase() + '>';\n          if (\n            this.endsWith(new_html, end_tag) &&\n            !this.endsWith(string.toLowerCase(), end_tag)\n          ) {\n            new_html = new_html.substring(0, new_html.length - end_tag.length);\n          }\n        } else if (string[0] !== '<' || string[string.length - 1] !== '>') {\n          this.write_buff += string;\n          return;\n        }\n      }\n      new_html = this.reconstructDocType(inner_doc.doctype) + new_html;\n    }\n\n    return new_html;\n  }\n\n  return string;\n};\n\n/**\n * Rewrites a CSS style string found in the style property of an element or\n * FontFace\n * @param {string} orig\n * @return {string}\n */\nWombat.prototype.rewriteInlineStyle = function(orig) {\n  var decoded;\n\n  try {\n    decoded = decodeURIComponent(orig);\n  } catch (e) {\n    decoded = orig;\n  }\n\n  if (decoded !== orig) {\n    var parts = this.rewriteStyle(decoded).split(',', 2);\n    return parts[0] + ',' + encodeURIComponent(parts[1]);\n  }\n\n  return this.rewriteStyle(orig);\n};\n\n/**\n * Rewrites the supplied cookie\n * @param {string} cookie\n * @return {string}\n */\nWombat.prototype.rewriteCookie = function(cookie) {\n  var wombat = this;\n  var rwCookie = cookie\n    .replace(this.wb_abs_prefix, '')\n    .replace(this.wb_rel_prefix, '');\n  rwCookie = rwCookie\n    .replace(this.cookie_domain_regex, function(m, m1) {\n      // rewrite domain\n      var message = {\n        domain: m1,\n        cookie: rwCookie,\n        wb_type: 'cookie'\n      };\n\n      // notify of cookie setting to allow server-side tracking\n      wombat.sendTopMessage(message, true);\n\n      // if no subdomain, eg. \"localhost\", just remove domain altogether\n      if (\n        wombat.$wbwindow.location.hostname.indexOf('.') >= 0 &&\n        !wombat.IP_RX.test(wombat.$wbwindow.location.hostname)\n      ) {\n        return 'Domain=.' + wombat.$wbwindow.location.hostname;\n      }\n      return '';\n    })\n    .replace(this.cookie_path_regex, function(m, m1) {\n      // rewrite path\n      var rewritten = wombat.rewriteUrl(m1);\n\n      if (rewritten.indexOf(wombat.wb_curr_host) === 0) {\n        rewritten = rewritten.substring(wombat.wb_curr_host.length);\n      }\n\n      return 'Path=' + rewritten;\n    });\n\n  // rewrite secure, if needed\n  if (wombat.$wbwindow.location.protocol !== 'https:') {\n    rwCookie = rwCookie.replace('secure', '');\n  }\n\n  return rwCookie.replace(',|', ',');\n};\n\n/**\n * Rewrites the supplied web worker URL\n * @param {string} workerUrl\n * @return {string}\n */\nWombat.prototype.rewriteWorker = function(workerUrl) {\n  if (!workerUrl) return workerUrl;\n  workerUrl = workerUrl.toString();\n  var isBlob = workerUrl.indexOf('blob:') === 0;\n  var isJS = workerUrl.indexOf('javascript:') === 0;\n  if (!isBlob && !isJS) {\n    if (\n      !this.startsWithOneOf(workerUrl, this.VALID_PREFIXES) &&\n      !this.startsWith(workerUrl, '/') &&\n      !this.startsWithOneOf(workerUrl, this.BAD_PREFIXES)\n    ) {\n      // super relative url assets/js/xyz.js\n      var rurl = this.resolveRelUrl(workerUrl, this.$wbwindow.document);\n      return this.rewriteUrl(rurl, false, 'wkr_', this.$wbwindow.document);\n    }\n    return this.rewriteUrl(workerUrl, false, 'wkr_', this.$wbwindow.document);\n  }\n\n  var workerCode = isJS ? workerUrl.replace('javascript:', '') : null;\n  if (isBlob) {\n    // fetching only skipped if it was JS url\n    var x = new XMLHttpRequest();\n    // use sync ajax request to get the contents, remove postMessage() rewriting\n    this.utilFns.XHRopen.call(x, 'GET', workerUrl, false);\n    this.utilFns.XHRsend.call(x);\n    workerCode = x.responseText\n      .replace(this.workerBlobRe, '')\n      // resolving blobs hit our sever side rewriting so we gotta\n      // ensure we good\n      .replace(this.rmCheckThisInjectRe, 'this');\n  }\n\n  if (this.wb_info.static_prefix || this.wb_info.ww_rw_script) {\n    var originalURL = this.$wbwindow.document.baseURI;\n    // if we are here we can must return blob so set makeBlob to true\n    var ww_rw =\n      this.wb_info.ww_rw_script ||\n      this.wb_info.static_prefix + 'wombatWorkers.js';\n    var rw =\n      '(function() { self.importScripts(\\'' +\n      ww_rw +\n      '\\'); new WBWombat({\\'prefix\\': \\'' +\n      this.wb_abs_prefix +\n      '\\', \\'prefixMod\\': \\'' +\n      this.wb_abs_prefix +\n      'wkrf_/\\', \\'originalURL\\': \\'' +\n      originalURL +\n      '\\'}); })();';\n\n    workerCode = rw + workerCode;\n  }\n  var blob = new Blob([workerCode], { type: 'application/javascript' });\n  return URL.createObjectURL(blob);\n};\n\n/**\n * Rewrite the arguments supplied to a function of the Text interface in order\n * to ensure CSS is rewritten when a text node is the child of the style tag\n * @param {Object} fnThis\n * @param {function} originalFn\n * @param {Object} argsObj\n */\nWombat.prototype.rewriteTextNodeFn = function(fnThis, originalFn, argsObj) {\n  var deproxiedThis = this.proxyToObj(fnThis);\n  var args;\n  if (\n    argsObj.length > 0 &&\n    deproxiedThis.parentElement &&\n    deproxiedThis.parentElement.tagName === 'STYLE'\n  ) {\n    // appendData(DOMString data); dataIndex = 0\n    // insertData(unsigned long offset, DOMString data); dataIndex = 1\n    // replaceData(unsigned long offset, unsigned long count, DOMString data); dataIndex = 2\n    args = new Array(argsObj.length);\n    var dataIndex = argsObj.length - 1;\n    if (dataIndex === 2) {\n      args[0] = argsObj[0];\n      args[1] = argsObj[1];\n    } else if (dataIndex === 1) {\n      args[0] = argsObj[0];\n    }\n    args[dataIndex] = this.rewriteStyle(argsObj[dataIndex]);\n  } else {\n    args = argsObj;\n  }\n  if (originalFn.__WB_orig_apply) {\n    return originalFn.__WB_orig_apply(deproxiedThis, args);\n  }\n  return originalFn.apply(deproxiedThis, args);\n};\n\n/**\n * Rewrite the arguments supplied to a function of the ChildNode interface\n * in order to ensure that elements are rewritten\n * @param {Object} fnThis\n * @param {function} originalFn\n * @param {Object} argsObj\n */\nWombat.prototype.rewriteChildNodeFn = function(fnThis, originalFn, argsObj) {\n  var thisObj = this.proxyToObj(fnThis);\n  if (argsObj.length === 0) return originalFn.call(thisObj);\n  var newArgs = this.rewriteElementsInArguments(argsObj);\n  if (originalFn.__WB_orig_apply) {\n    return originalFn.__WB_orig_apply(thisObj, newArgs);\n  }\n  return originalFn.apply(thisObj, newArgs);\n};\n\n/**\n * Rewrites the arguments supplied to Element.[insertAdjacentElement, insertAdjacentHTML].\n * If rwHTML is true the rewrite performed is done by {@link rewriteHtml} other wise\n * {@link rewriteElemComplete}\n * @param {Object} fnThis\n * @param {function} originalFn\n * @param {number} position\n * @param {string|Node} textOrElem\n * @param {boolean} rwHTML\n * @return {*}\n */\nWombat.prototype.rewriteInsertAdjHTMLOrElemArgs = function(\n  fnThis,\n  originalFn,\n  position,\n  textOrElem,\n  rwHTML\n) {\n  var fnThisObj = this.proxyToObj(fnThis);\n  if (fnThisObj._no_rewrite) {\n    return originalFn.call(fnThisObj, position, textOrElem);\n  }\n  if (rwHTML) {\n    return originalFn.call(fnThisObj, position, this.rewriteHtml(textOrElem));\n  }\n  this.rewriteElemComplete(textOrElem);\n  return originalFn.call(fnThisObj, position, textOrElem);\n};\n\n/**\n * Rewrites the arguments of either setTimeout or setInterval because\n * [setTimeout|setInterval]('document.location.href = \"xyz.com\"', time)\n * is legal and used\n * @param {Object} fnThis\n * @param {function} originalFn\n * @param {Object} argsObj\n * @return {*}\n */\nWombat.prototype.rewriteSetTimeoutInterval = function(\n  fnThis,\n  originalFn,\n  argsObj\n) {\n  // strings are primitives with a prototype or __proto__ of String depending on the browser\n  var rw = this.isString(argsObj[0]);\n  // do not mess with the arguments object unless you want instant de-optimization\n  var args = rw ? new Array(argsObj.length) : argsObj;\n  if (rw) {\n    if (this.$wbwindow.Proxy) {\n      args[0] = this.wrapScriptTextJsProxy(argsObj[0]);\n    } else {\n      args[0] = argsObj[0].replace(/\\blocation\\b/g, 'WB_wombat_$&');\n    }\n    for (var i = 1; i < argsObj.length; ++i) {\n      args[i] = this.proxyToObj(argsObj[i]);\n    }\n  }\n  // setTimeout|setInterval does not require its this arg to be window so just in case\n  // someone got funky with it\n  var thisObj = this.proxyToObj(fnThis);\n  if (originalFn.__WB_orig_apply) {\n    return originalFn.__WB_orig_apply(thisObj, args);\n  }\n  return originalFn.apply(thisObj, args);\n};\n\n/**\n * Rewrites the value of used in to set SomeElement.[innerHTML|outerHTML]\n * iframe.srcdoc, or style.textContent handling edge cases e.g. script tags.\n *\n * If the element is a style tag and it has a sheet after the new value is set\n * it, the sheet, is checked for media rules.\n *\n * @param {Object} thisObj\n * @param {Function} oSetter\n * @param {?string} newValue\n */\nWombat.prototype.rewriteHTMLAssign = function(thisObj, oSetter, newValue) {\n  var res = newValue;\n  var tagName = thisObj.tagName;\n  if (!thisObj._no_rewrite && !(thisObj instanceof this.$wbwindow.HTMLTemplateElement)) {\n    if (tagName === 'STYLE') {\n      res = this.rewriteStyle(newValue);\n    } else if (tagName === 'SCRIPT') {\n      // script tags are used to hold HTML for later use\n      // check if this contains tags or a script\n\n      if (newValue && this.IsTagRegex.test(newValue)) {\n        res = this.rewriteHtml(newValue);\n      }\n\n      // likely actual JS, not tags\n      if (res === newValue) {\n        if (\n          !this.skipWrapScriptBasedOnType(thisObj.type) &&\n          !this.skipWrapScriptTextBasedOnText(newValue)\n        ) {\n          res = this.wrapScriptTextJsProxy(res);\n        }\n      }\n    } else {\n      res = this.rewriteHtml(newValue);\n    }\n  }\n  oSetter.call(thisObj, res);\n  if (\n    this.wbUseAFWorker &&\n    this.WBAutoFetchWorker &&\n    tagName === 'STYLE' &&\n    thisObj.sheet != null\n  ) {\n    // got to preserve all the things\n    this.WBAutoFetchWorker.deferredSheetExtraction(thisObj.sheet);\n  }\n};\n\n/**\n * Rewrites the value to be supplied to eval or our injected wrapper\n * @param {Function} rawEvalOrWrapper\n * @param {*} evalArg\n * @return {*}\n */\nWombat.prototype.rewriteEvalArg = function(rawEvalOrWrapper, evalArg, extraArg) {\n  var toBeEvald =\n    this.isString(evalArg) && !this.skipWrapScriptTextBasedOnText(evalArg)\n      ? this.wrapScriptTextJsProxy(evalArg)\n      : this.otherEvalRewrite(evalArg);\n  return rawEvalOrWrapper(toBeEvald, extraArg);\n};\n\n/**\n * Apply other eval specific rewriting\n * Currently just rewrite import('')\n *\n */\n\nWombat.prototype.otherEvalRewrite = function(value) {\n  if (typeof(value) !== 'string') {\n    return value;\n  }\n  return value.replace(this.IMPORT_JS_REGEX, this.styleReplacer);\n};\n\n/**\n * Applies an Event property getter override for the supplied property\n * @param {string} attr\n * @param {Object} [eventProto]\n */\nWombat.prototype.addEventOverride = function(attr, eventProto) {\n  var theProto = eventProto;\n  if (!eventProto) {\n    theProto = this.$wbwindow.MessageEvent.prototype;\n  }\n  var origGetter = this.getOrigGetter(theProto, attr);\n  if (!origGetter) return;\n  this.defGetterProp(theProto, attr, function() {\n    if (this['_' + attr] != null) {\n      return this['_' + attr];\n    }\n    return origGetter.call(this);\n  });\n};\n\n/**\n * Returns T/F indicating if the supplied attribute node is to be rewritten\n * @param {Object} attr\n * @return {boolean}\n */\nWombat.prototype.isAttrObjRewrite = function(attr) {\n  if (!attr) return false;\n  var tagName = attr.ownerElement && attr.ownerElement.tagName;\n  return this.shouldRewriteAttr(tagName, attr.nodeName);\n};\n\n/**\n * Defines a new getter and setter function for the supplied\n * property of the Attr interface\n * @param {Object} attrProto\n * @param {string} prop\n */\nWombat.prototype.newAttrObjGetSet = function(attrProto, prop) {\n  var wombat = this;\n  var oGetter = this.getOrigGetter(attrProto, prop);\n  var oSetter = this.getOrigSetter(attrProto, prop);\n  this.defProp(\n    attrProto,\n    prop,\n    function newAttrObjSetter(newValue) {\n      var obj = wombat.proxyToObj(this);\n      var res = newValue;\n      if (wombat.isAttrObjRewrite(obj)) {\n        res = wombat.performAttributeRewrite(\n          obj.ownerElement,\n          obj.name,\n          newValue,\n          false\n        );\n      }\n      return oSetter.call(obj, res);\n    },\n    function newAttrObjGetter() {\n      var obj = wombat.proxyToObj(this);\n      var res = oGetter.call(obj);\n      if (wombat.isAttrObjRewrite(obj)) {\n        return wombat.extractOriginalURL(res);\n      }\n      return res;\n    }\n  );\n};\n\n/**\n * Overrides the nodeValue property of the Attr interface\n */\nWombat.prototype.overrideAttrProps = function() {\n  var attrProto = this.$wbwindow.Attr.prototype;\n  this.newAttrObjGetSet(attrProto, 'value');\n  this.newAttrObjGetSet(attrProto, 'nodeValue');\n  this.newAttrObjGetSet(attrProto, 'textContent');\n};\n\n/**\n * Applies an override the attribute get/set override\n * @param {Object} obj\n * @param {string} attr\n * @param {string} mod\n */\nWombat.prototype.overrideAttr = function(obj, attr, mod) {\n  var orig_getter = this.getOrigGetter(obj, attr);\n  var orig_setter = this.getOrigSetter(obj, attr);\n  var wombat = this;\n\n  var setter = function newAttrPropSetter(orig) {\n    if (mod === 'js_' && !this.__$removedWBOSRC$__) {\n      wombat.removeWBOSRC(this);\n    }\n    var val = wombat.rewriteUrl(orig, false, mod);\n    if (orig_setter) {\n      return orig_setter.call(this, val);\n    } else if (wombat.wb_setAttribute) {\n      return wombat.wb_setAttribute.call(this, attr, val);\n    }\n  };\n\n  var getter = function newAttrPropGetter() {\n    var res;\n    if (orig_getter) {\n      res = orig_getter.call(this);\n    } else if (wombat.wb_getAttribute) {\n      res = wombat.wb_getAttribute.call(this, attr);\n    }\n    res = wombat.extractOriginalURL(res);\n    if (this.__WB_blank && res === 'about:blank') {\n      return '';\n    }\n    return res;\n  };\n\n  this.defProp(obj, attr, setter, getter);\n};\n\n/**\n * Applies an attribute getter override IFF an original getter exists\n * @param {Object} proto\n * @param {string} prop\n * @param {*} [cond]\n */\nWombat.prototype.overridePropExtract = function(proto, prop) {\n  var orig_getter = this.getOrigGetter(proto, prop);\n  var wombat = this;\n  if (orig_getter) {\n    var new_getter = function () {\n      var obj = wombat.proxyToObj(this);\n      var res = orig_getter.call(obj);\n      return wombat.extractOriginalURL(res);\n    };\n    this.defGetterProp(proto, prop, new_getter);\n  }\n};\n\n\n/**\n * Overrides referrer -- if top-replay frame, referrer should be \"\", otherwise extractOriginURL\n * @param {Object} proto\n * @param {string} prop\n * @param {*} [cond]\n */\nWombat.prototype.overrideReferrer = function($document) {\n  var orig_getter = this.getOrigGetter($document, 'referrer');\n  var wombat = this;\n  if (orig_getter) {\n    var new_getter = function() {\n      var obj = wombat.proxyToObj(this);\n\n      var $win = this.defaultView;\n\n      // if top replay-frame, referrer should always be \"\"\n      if ($win === $win.__WB_replay_top) {\n        return '';\n      }\n\n      var res = orig_getter.call(obj);\n\n      return wombat.extractOriginalURL(res);\n    };\n    this.defGetterProp($document, 'referrer', new_getter);\n  }\n};\n\n\n/**\n * Applies an attribute getter override IFF an original getter exists that\n * ensures that the results of retrieving the attributes value is not a\n * wombat Proxy\n * @param {Object} proto\n * @param {string} prop\n */\nWombat.prototype.overridePropToProxy = function(proto, prop) {\n  var orig_getter = this.getOrigGetter(proto, prop);\n  if (orig_getter) {\n    var wombat = this;\n    var new_getter = function overridePropToProxyNewGetter() {\n      return wombat.objToProxy(orig_getter.call(this));\n    };\n    this.defGetterProp(proto, prop, new_getter);\n  }\n};\n\n/**\n * Applies an override to supplied history function name IFF it exists\n * @param {string} funcName\n * @return {?function}\n */\nWombat.prototype.overrideHistoryFunc = function(funcName) {\n  if (!this.$wbwindow.history) return undefined;\n  var orig_func = this.$wbwindow.history[funcName];\n  if (!orig_func) return undefined;\n\n  this.$wbwindow.history['_orig_' + funcName] = orig_func;\n\n  this.$wbwindow.history.___wb_ownWindow = this.$wbwindow;\n\n  var wombat = this;\n\n  var rewrittenFunc = function histNewFunc(stateObj, title, url) {\n    // in case functions rebound to different history obj!\n    var historyWin = this.___wb_ownWindow || wombat.$wbwindow;\n\n    var wombatLocation = historyWin.WB_wombat_location;\n    var rewritten_url;\n    var resolvedURL;\n    if (url) {\n      var parser = wombat._makeURLParser(url, historyWin.document);\n      resolvedURL = parser.href;\n\n      rewritten_url = wombat.rewriteUrl(resolvedURL);\n\n      if (\n        resolvedURL !== wombatLocation.origin &&\n        wombatLocation.href !== 'about:blank' &&\n        !wombat.startsWith(resolvedURL, wombatLocation.origin + '/')\n      ) {\n        throw new DOMException('Invalid history change: ' + resolvedURL);\n      }\n    } else {\n      resolvedURL = wombatLocation.href;\n    }\n\n    orig_func.call(this, stateObj, title, rewritten_url);\n\n    var origTitle = historyWin.document.title;\n\n    if (wombat.WBAutoFetchWorker) {\n      historyWin.setTimeout(function() {\n        if (!title && historyWin.document.title !== origTitle) {\n          title = historyWin.document.title;\n        }\n\n        wombat.WBAutoFetchWorker.fetchAsPage(rewritten_url, resolvedURL, title);\n      }, 100);\n    }\n\n    wombat.sendHistoryUpdate(resolvedURL, title, historyWin);\n  };\n\n  this.$wbwindow.history[funcName] = rewrittenFunc;\n  if (this.$wbwindow.History && this.$wbwindow.History.prototype) {\n    this.$wbwindow.History.prototype[funcName] = rewrittenFunc;\n  }\n\n  return rewrittenFunc;\n};\n\n/**\n * Applies an getter/setter override to the supplied style interface's attribute\n * and prop name combination\n * @param {Object} obj\n * @param {string} attr\n * @param {string} [propName]\n */\nWombat.prototype.overrideStyleAttr = function(obj, attr, propName) {\n  var orig_getter = this.getOrigGetter(obj, attr);\n  var orig_setter = this.getOrigSetter(obj, attr);\n\n  var wombat = this;\n\n  var setter = function overrideStyleAttrSetter(orig) {\n    var val = wombat.rewriteStyle(orig);\n    if (orig_setter) {\n      orig_setter.call(this, val);\n    } else {\n      this.setProperty(propName, val);\n    }\n    return val;\n  };\n\n  var getter = orig_getter;\n\n  var extractUrl = function (_, p1, p2, p3, p4) {\n    return p1 + (p2 || '') + wombat.extractOriginalURL(p3) + p4;\n  };\n\n  var EXTRACT_URL_RX = /(url\\()(['\"])?(.*?)(\\2\\))/;\n\n  if (!orig_getter) {\n    getter = function overrideStyleAttrGetter() {\n      var res = this.getPropertyValue(propName);\n      if (res && res.startsWith('url(')) {\n        res = res.replace(EXTRACT_URL_RX, extractUrl);\n      }\n      return res;\n    };\n  }\n\n  if ((orig_setter && orig_getter) || propName) {\n    this.defProp(obj, attr, setter, getter);\n  }\n};\n\n/**\n * Applies an override to the setProperty function\n * @param style_proto\n */\nWombat.prototype.overrideStyleSetProp = function(style_proto) {\n  var orig_setProp = style_proto.setProperty;\n  var wombat = this;\n  style_proto.setProperty = function rwSetProperty(name, value, priority) {\n    var rwvalue = wombat.rewriteStyle(value);\n    return orig_setProp.call(this, name, rwvalue, priority);\n  };\n};\n\n/**\n * Overrides the getter and setter functions for the properties listed in\n * {@link Wombat#URL_PROPS} for the `a` and `area` tags\n * @param {Object} whichObj\n */\nWombat.prototype.overrideAnchorAreaElem = function(whichObj) {\n  if (!whichObj || !whichObj.prototype) return;\n  var originalGetSets = {};\n  var originalProto = whichObj.prototype;\n\n  var anchorAreaSetter = function anchorAreaSetter(prop, value) {\n    var func = originalGetSets['set_' + prop];\n    if (func) return func.call(this, value);\n    return '';\n  };\n\n  var anchorAreaGetter = function anchorAreaGetter(prop) {\n    var func = originalGetSets['get_' + prop];\n    if (func) return func.call(this);\n    return '';\n  };\n\n  for (var i = 0; i < this.URL_PROPS.length; i++) {\n    var prop = this.URL_PROPS[i];\n    originalGetSets['get_' + prop] = this.getOrigGetter(originalProto, prop);\n    originalGetSets['set_' + prop] = this.getOrigSetter(originalProto, prop);\n    if (Object.defineProperty) {\n      this.defProp(\n        originalProto,\n        prop,\n        this.makeSetLocProp(prop, anchorAreaSetter, anchorAreaGetter),\n        this.makeGetLocProp(prop, anchorAreaGetter),\n        true\n      );\n    }\n  }\n\n  originalProto.toString = function toString() {\n    return this.href;\n  };\n};\n\n/**\n * Overrides the getter and setter functions for the `innerHTML` and `outerHTML`\n * properties of the supplied element\n * @param {Object} elem\n * @param {string} prop\n * @param {boolean} [rewriteGetter]\n */\nWombat.prototype.overrideHtmlAssign = function(elem, prop, rewriteGetter) {\n  if (!this.$wbwindow.DOMParser || !elem || !elem.prototype) {\n    return;\n  }\n\n  var obj = elem.prototype;\n\n  var orig_getter = this.getOrigGetter(obj, prop);\n  var orig_setter = this.getOrigSetter(obj, prop);\n\n  if (!orig_setter) return;\n\n  var rewriteFn = this.rewriteHTMLAssign;\n\n  var setter = function overrideHTMLAssignSetter(orig) {\n    return rewriteFn(this, orig_setter, orig);\n  };\n\n  var wb_unrewrite_rx = this.wb_unrewrite_rx;\n\n  var getter = function overrideHTMLAssignGetter() {\n    var res = orig_getter.call(this);\n    if (!this._no_rewrite) {\n      return res.replace(wb_unrewrite_rx, '');\n    }\n    return res;\n  };\n\n  this.defProp(obj, prop, setter, rewriteGetter ? getter : orig_getter);\n};\n\nWombat.prototype.overrideHtmlAssignSrcDoc = function(elem, prop) {\n  var obj = elem.prototype;\n\n  var orig_getter = this.getOrigGetter(obj, prop);\n  var orig_setter = this.getOrigSetter(obj, prop);\n\n  var wombat = this;\n\n  var setter = function overrideSetter(orig) {\n    this.__wb_srcdoc = orig;\n\n    if (wombat.wb_info.isSW) {\n      wombat.blobUrlForIframe(this, orig);\n      return orig;\n    } else {\n      return wombat.rewriteHTMLAssign(this, orig_setter, orig);\n    }\n  };\n\n  var getter = function overrideGetter() {\n    return this.__wb_srcdoc;\n  };\n\n  this.defProp(obj, prop, setter, getter);\n};\n\n\n/**\n * Override .dataset attribute on element and wraps in a proxy that unrewrites URLs\n */\nWombat.prototype.overrideDataSet = function() {\n  var obj = this.$wbwindow.HTMLElement.prototype;\n  var orig_getter = this.getOrigGetter(obj, 'dataset');\n\n  var wombat = this;\n\n  var getter = function wrapDataSet() {\n    var dataset = orig_getter.call(this);\n\n    var proxy = new Proxy(dataset, {\n      get(target, prop, receiver) {\n\n        var result = target[prop];\n\n        if (wombat.startsWithOneOf(result, wombat.wb_prefixes)) {\n          return wombat.extractOriginalURL(result);\n        }\n\n        return result;\n      }\n    });\n\n    return proxy;\n  };\n\n  this.defProp(obj, 'dataset', null, getter);\n};\n\n\n/**\n * Override .style attribute on element and wraps in a proxy that unrewrites URLs\n */\nWombat.prototype.overrideStyleProxy = function(overrideProps) {\n  var obj = this.$wbwindow.HTMLElement.prototype;\n  var orig_setter = this.getOrigSetter(obj, 'style');\n  var orig_getter = this.getOrigGetter(obj, 'style');\n\n  var wombat = this;\n\n  var getter = function wrapStyle() {\n    var style = orig_getter.call(this);\n\n    var fnCache = {};\n\n    var proxy = new Proxy(style, {\n      set(target, prop, value) {\n        if (overrideProps.includes(prop)) {\n          value = wombat.rewriteStyle(value);\n        }\n\n        target[prop] = value;\n        return true;\n      },\n\n      get(target, prop, receiver) {\n        var value = target[prop];\n\n        if (typeof value === 'function' && (prop === 'setProperty' || wombat.isNativeFunction(value))) {\n          if (!fnCache[prop]) {\n            fnCache[prop] = value.bind(style);\n          }\n          return fnCache[prop];\n        }\n\n        return value;\n      },\n    });\n\n    return proxy;\n  };\n\n  this.defProp(obj, 'style', orig_setter, getter);\n};\n\n\n\n/**\n * Overrides the getter and setter functions for the supplied property\n * on the HTMLIFrameElement\n * @param {string} prop\n */\nWombat.prototype.overrideIframeContentAccess = function(prop) {\n  if (\n    !this.$wbwindow.HTMLIFrameElement ||\n    !this.$wbwindow.HTMLIFrameElement.prototype\n  ) {\n    return;\n  }\n\n  var obj = this.$wbwindow.HTMLIFrameElement.prototype;\n  var orig_getter = this.getOrigGetter(obj, prop);\n\n  if (!orig_getter) return;\n\n  var orig_setter = this.getOrigSetter(obj, prop);\n  var wombat = this;\n  var getter = function overrideIframeContentAccessGetter() {\n    wombat.initIframeWombat(this);\n    return wombat.objToProxy(orig_getter.call(this));\n  };\n\n  this.defProp(obj, prop, orig_setter, getter);\n  obj['_get_' + prop] = orig_getter;\n};\n\n/**\n * Applies an override to the getter function for the frames property of\n * the supplied window in order to ensure that wombat is initialized in\n * all frames.\n * * @param {Window} $wbwindow\n */\nWombat.prototype.overrideFramesAccess = function($wbwindow) {\n  // If $wbwindow.frames is the window itself, nothing to override\n  // This can be handled in the Obj Proxy\n  if ($wbwindow.Proxy && $wbwindow === $wbwindow.frames) {\n    return;\n  }\n  $wbwindow.__wb_frames = $wbwindow.frames;\n  var wombat = this;\n  var getter = function overrideFramesAccessGetter() {\n    for (var i = 0; i < this.__wb_frames.length; i++) {\n      try {\n        wombat.initNewWindowWombat(this.__wb_frames[i]);\n      } catch (e) {}\n    }\n    return this.__wb_frames;\n  };\n\n  this.defGetterProp($wbwindow, 'frames', getter);\n  this.defGetterProp($wbwindow.Window.prototype, 'frames', getter);\n};\n\n\nWombat.prototype.overrideSWAccess = function($wbwindow) {\n  if (!$wbwindow.navigator.serviceWorker || !$wbwindow.navigator.serviceWorker.controller) {\n    return;\n  }\n\n  $wbwindow._WB_wombat_sw = $wbwindow.navigator.serviceWorker;\n\n\n  var overrideSW = {\n                  'controller': null,\n                  'ready': Promise.resolve({'unregister': function() {} }),\n                  'register': function() { return Promise.reject(); },\n                  'addEventListener': function() {},\n                  'removeEventListener': function() {},\n                  'onmessage': null,\n                  'oncontrollerchange': null,\n                  'getRegistrations': function() { return Promise.resolve([]); },\n                  'getRegistration': function() { return Promise.resolve(undefined); },\n                  'startMessages': function() {}\n                 };\n\n  this.defGetterProp($wbwindow.navigator, 'serviceWorker', function() { return overrideSW; });\n};\n\n\n\n/**\n * Overrides the supplied method in order to ensure that the `this` argument\n * of the function is not one of the JS Proxy objects used by wombat.\n * @param {object} cls\n * @param {string} method\n * @param {Object} [obj]\n */\nWombat.prototype.overrideFuncThisProxyToObj = function(cls, method, obj) {\n  if (!cls) return;\n\n  var ovrObj = obj;\n  if (!obj && cls.prototype && cls.prototype[method]) {\n    ovrObj = cls.prototype;\n  } else if (!obj && cls[method]) {\n    ovrObj = cls;\n  }\n\n  if (!ovrObj) return;\n\n  var wombat = this;\n  var orig = ovrObj[method];\n  ovrObj[method] = function deproxyThis() {\n    return orig.apply(wombat.proxyToObj(this), arguments);\n  };\n};\n\n/**\n * Applies an function override that ensures that the argument the supplied index\n * is not one of the JS Proxy objects used by wombat.\n * @param {Object} cls\n * @param {string} method\n * @param {number} [argumentIdx]\n */\nWombat.prototype.overrideFuncArgProxyToObj = function(\n  cls,\n  method,\n  argumentIdx\n) {\n  if (!cls || !cls.prototype) return;\n  var argIndex = argumentIdx || 0;\n  var orig = cls.prototype[method];\n  if (!orig) return;\n  var wombat = this;\n  cls.prototype[method] = function deproxyFnArg() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      if (i === argIndex) {\n        args[i] = wombat.proxyToObj(arguments[i]);\n      } else {\n        args[i] = arguments[i];\n      }\n    }\n    var thisObj = wombat.proxyToObj(this);\n    if (orig.__WB_orig_apply) {\n      return orig.__WB_orig_apply(thisObj, args);\n    }\n    return orig.apply(thisObj, args);\n  };\n};\n\n/**\n * Overrides Function.prototype.apply in order to ensure that none of the\n * arguments of `native` functions are one of the JS Proxy objects used by wombat.\n * @param {Window} $wbwindow\n */\nWombat.prototype.overrideFunctionApply = function($wbwindow) {\n  if ($wbwindow.Function.prototype.__WB_orig_apply) {\n    return;\n  }\n  var orig_apply = $wbwindow.Function.prototype.apply;\n  $wbwindow.Function.prototype.__WB_orig_apply = orig_apply;\n  var wombat = this;\n  $wbwindow.Function.prototype.apply = function apply(obj, args) {\n    // if native function, de-proxy\n    if (wombat.isNativeFunction(this)) {\n      obj = wombat.proxyToObj(obj);\n      args = wombat.deproxyArrayHandlingArgumentsObj(args);\n    }\n\n    return this.__WB_orig_apply(obj, args);\n  };\n\n  this.wb_funToString.apply = orig_apply;\n};\n\n\n/**\n * Override Function.prototype.bind to deproxy the param target\n * in case of native functions\n *\n */\nWombat.prototype.overrideFunctionBind = function($wbwindow) {\n  if ($wbwindow.Function.prototype.__WB_orig_bind) {\n    return;\n  }\n  var orig_bind = $wbwindow.Function.prototype.bind;\n  $wbwindow.Function.prototype.__WB_orig_bind = orig_bind;\n  var wombat = this;\n  $wbwindow.Function.prototype.bind = function bind(obj) {\n    var isNative = wombat.isNativeFunction(this);\n    var result = this.__WB_orig_bind.apply(this, arguments);\n    result.__WB_is_native_func__ = isNative;\n    return result;\n  };\n};\n\n\n\n\n/**\n * Overrides the getter and setter functions for the `srcset` property\n * of the supplied Object in order to rewrite accesses and retrievals\n * @param {Object} obj\n * @param {string} [mod]\n */\nWombat.prototype.overrideSrcsetAttr = function(obj, mod) {\n  var prop = 'srcset';\n  var orig_getter = this.getOrigGetter(obj, prop);\n  var orig_setter = this.getOrigSetter(obj, prop);\n  var wombat = this;\n\n  var setter = function srcset(orig) {\n    var val = wombat.rewriteSrcset(orig, this);\n    if (orig_setter) {\n      return orig_setter.call(this, val);\n    } else if (wombat.wb_setAttribute) {\n      return wombat.wb_setAttribute.call(this, prop, val);\n    }\n  };\n\n  var getter = function srcset() {\n    var res;\n    if (orig_getter) {\n      res = orig_getter.call(this);\n    } else if (wombat.wb_getAttribute) {\n      res = wombat.wb_getAttribute.call(this, prop);\n    }\n    res = wombat.extractOriginalURL(res);\n    return res;\n  };\n\n  this.defProp(obj, prop, setter, getter);\n};\n\n/**\n * Overrides the getter and setter functions for the `href` property\n * of the supplied Object in order to rewrite accesses and retrievals\n * @param {Object} obj\n * @param {string} mod\n */\nWombat.prototype.overrideHrefAttr = function(obj, mod) {\n  var orig_getter = this.getOrigGetter(obj, 'href');\n  var orig_setter = this.getOrigSetter(obj, 'href');\n\n  var wombat = this;\n\n  var setter = function href(orig) {\n    var val;\n    if (mod === 'cs_' && orig.indexOf('data:text/css') === 0) {\n      val = wombat.rewriteInlineStyle(orig);\n    } else if (this.tagName === 'LINK') {\n      val = wombat.rewriteUrl(\n        orig,\n        false,\n        wombat.rwModForElement(this, 'href')\n      );\n    } else {\n      val = wombat.rewriteUrl(orig, false, mod, this.ownerDocument);\n    }\n    if (orig_setter) {\n      return orig_setter.call(this, val);\n    } else if (wombat.wb_setAttribute) {\n      return wombat.wb_setAttribute.call(this, 'href', val);\n    }\n  };\n\n  var getter = function href() {\n    var res;\n    if (orig_getter) {\n      res = orig_getter.call(this);\n    } else if (wombat.wb_getAttribute) {\n      res = wombat.wb_getAttribute.call(this, 'href');\n    }\n    if (!this._no_rewrite) return wombat.extractOriginalURL(res);\n    return res;\n  };\n\n  this.defProp(obj, 'href', setter, getter);\n};\n\n/**\n * Overrides the getter and setter functions for a property of the Text\n * interface in order to rewrite accesses and retrievals when a text node\n * is the child of the style tag\n * @param {Object} textProto\n * @param {string} whichProp\n */\nWombat.prototype.overrideTextProtoGetSet = function(textProto, whichProp) {\n  var orig_getter = this.getOrigGetter(textProto, whichProp);\n  var wombat = this;\n  var setter;\n  // data, from CharacterData, is both readable and writable whereas wholeText, from Text, is not\n  if (whichProp === 'data') {\n    var orig_setter = this.getOrigSetter(textProto, whichProp);\n    setter = function rwTextProtoSetter(orig) {\n      var res = orig;\n      if (\n        !this._no_rewrite &&\n        this.parentElement &&\n        this.parentElement.tagName === 'STYLE'\n      ) {\n        res = wombat.rewriteStyle(orig);\n      }\n      return orig_setter.call(this, res);\n    };\n  }\n  var getter = function rwTextProtoGetter() {\n    var res = orig_getter.call(this);\n    if (\n      !this._no_rewrite &&\n      this.parentElement &&\n      this.parentElement.tagName === 'STYLE'\n    ) {\n      return res.replace(wombat.wb_unrewrite_rx, '');\n    }\n    return res;\n  };\n  this.defProp(textProto, whichProp, setter, getter);\n};\n\n/**\n * Overrides the constructor of an UIEvent object in order to ensure\n * that the `view`, `relatedTarget`, and `target` arguments of the\n * constructor are not a JS Proxy used by wombat.\n * @param {string} which\n */\nWombat.prototype.overrideAnUIEvent = function(which) {\n  var didOverrideKey = '__wb_' + which + '_overridden';\n  var ConstructorFN = this.$wbwindow[which];\n  if (\n    !ConstructorFN ||\n    !ConstructorFN.prototype ||\n    ConstructorFN.prototype[didOverrideKey]\n  )\n    return;\n  // ensure if and when view is accessed it is proxied\n  var wombat = this;\n  this.overridePropToProxy(ConstructorFN.prototype, 'view');\n  var initFNKey = 'init' + which;\n  if (ConstructorFN.prototype[initFNKey]) {\n    var originalInitFn = ConstructorFN.prototype[initFNKey];\n    ConstructorFN.prototype[initFNKey] = function() {\n      var thisObj = wombat.proxyToObj(this);\n      if (arguments.length === 0 || arguments.length < 3) {\n        if (originalInitFn.__WB_orig_apply) {\n          return originalInitFn.__WB_orig_apply(thisObj, arguments);\n        }\n        return originalInitFn.apply(thisObj, arguments);\n      }\n      var newArgs = new Array(arguments.length);\n      for (var i = 0; i < arguments.length; i++) {\n        if (i === 3) {\n          newArgs[i] = wombat.proxyToObj(arguments[i]);\n        } else {\n          newArgs[i] = arguments[i];\n        }\n      }\n      if (originalInitFn.__WB_orig_apply) {\n        return originalInitFn.__WB_orig_apply(thisObj, newArgs);\n      }\n      return originalInitFn.apply(thisObj, newArgs);\n    };\n  }\n  this.$wbwindow[which] = (function(EventConstructor) {\n    return function NewEventConstructor(type, init) {\n      wombat.domConstructorErrorChecker(this, which, arguments);\n      if (init) {\n        if (init.view != null) {\n          init.view = wombat.proxyToObj(init.view);\n        }\n        if (init.relatedTarget != null) {\n          init.relatedTarget = wombat.proxyToObj(init.relatedTarget);\n        }\n        if (init.target != null) {\n          init.target = wombat.proxyToObj(init.target);\n        }\n      }\n      return new EventConstructor(type, init);\n    };\n  })(ConstructorFN);\n  this.$wbwindow[which].prototype = ConstructorFN.prototype;\n  Object.defineProperty(this.$wbwindow[which].prototype, 'constructor', {\n    value: this.$wbwindow[which]\n  });\n  this.$wbwindow[which].prototype[didOverrideKey] = true;\n};\n\n/**\n * Rewrites the arguments supplied to the functions of the ParentNode interface\n * @param {Object} fnThis\n * @param {function} originalFn\n * @param {Object} argsObj\n * @return {*}\n */\nWombat.prototype.rewriteParentNodeFn = function(fnThis, originalFn, argsObj) {\n  var argArr = this._no_rewrite\n    ? argsObj\n    : this.rewriteElementsInArguments(argsObj);\n  var thisObj = this.proxyToObj(fnThis);\n  if (originalFn.__WB_orig_apply) {\n    return originalFn.__WB_orig_apply(thisObj, argArr);\n  }\n  return originalFn.apply(thisObj, argArr);\n};\n\n/**\n * Overrides the append and prepend functions on the supplied object in order\n * to ensure that the elements or string of HTML supplied as arguments to these\n * functions are rewritten\n * @param {Object} obj\n * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append\n * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend\n */\nWombat.prototype.overrideParentNodeAppendPrepend = function(obj) {\n  var rewriteParentNodeFn = this.rewriteParentNodeFn;\n  if (obj.prototype.append) {\n    var originalAppend = obj.prototype.append;\n    obj.prototype.append = function append() {\n      return rewriteParentNodeFn(this, originalAppend, arguments);\n    };\n  }\n  if (obj.prototype.prepend) {\n    var originalPrepend = obj.prototype.prepend;\n    obj.prototype.prepend = function prepend() {\n      return rewriteParentNodeFn(this, originalPrepend, arguments);\n    };\n  }\n};\n\n/**\n * Overrides the `innerHTML` property and `append`, `prepend` functions\n * on the ShadowRoot interface in order to ensure any HTML elements\n * added via these methods are rewritten\n * @see https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n */\nWombat.prototype.overrideShadowDom = function() {\n  if (!this.$wbwindow.ShadowRoot || !this.$wbwindow.ShadowRoot.prototype) {\n    return;\n  }\n  // shadow root inherits from DocumentFragment, Node, and ParentNode not Element\n  this.overrideHtmlAssign(this.$wbwindow.ShadowRoot, 'innerHTML', true);\n  this.overrideParentNodeAppendPrepend(this.$wbwindow.ShadowRoot);\n};\n\n/**\n * Applies an override to the ChildNode interface that is inherited by\n * the supplied Object. If the textIface argument is truthy the rewrite function\n * used is {@link rewriteChildNodeFn} otherwise {@link rewriteTextNodeFn}\n * @param {*} ifaceWithChildNode\n * @param {boolean} [textIface]\n */\nWombat.prototype.overrideChildNodeInterface = function(\n  ifaceWithChildNode,\n  textIface\n) {\n  if (!ifaceWithChildNode || !ifaceWithChildNode.prototype) return;\n  var rewriteFn = textIface ? this.rewriteTextNodeFn : this.rewriteChildNodeFn;\n  if (ifaceWithChildNode.prototype.before) {\n    var originalBefore = ifaceWithChildNode.prototype.before;\n    ifaceWithChildNode.prototype.before = function before() {\n      return rewriteFn(this, originalBefore, arguments);\n    };\n  }\n  if (ifaceWithChildNode.prototype.after) {\n    var originalAfter = ifaceWithChildNode.prototype.after;\n    ifaceWithChildNode.prototype.after = function after() {\n      return rewriteFn(this, originalAfter, arguments);\n    };\n  }\n  if (ifaceWithChildNode.prototype.replaceWith) {\n    var originalReplaceWith = ifaceWithChildNode.prototype.replaceWith;\n    ifaceWithChildNode.prototype.replaceWith = function replaceWith() {\n      return rewriteFn(this, originalReplaceWith, arguments);\n    };\n  }\n};\n\n/**\n * Applies overrides to the `appendData`, `insertData`, and `replaceData` functions\n * and `data` and `wholeText` properties on the Text interface in order to ensure\n * CSS strings are rewritten when Text nodes are children of the style tag\n */\nWombat.prototype.initTextNodeOverrides = function() {\n  var Text = this.$wbwindow.Text;\n  if (!Text || !Text.prototype) return;\n  // https://dom.spec.whatwg.org/#characterdata and https://dom.spec.whatwg.org/#interface-text\n  // depending on the JS frameworks used some pages include JS that will append a single text node child\n  // to a style tag and then progressively modify that text nodes data for changing the css values that\n  // style tag contains\n  var textProto = Text.prototype;\n  // override inherited CharacterData functions\n  var rewriteTextProtoFunction = this.rewriteTextNodeFn;\n  if (textProto.appendData) {\n    var originalAppendData = textProto.appendData;\n    textProto.appendData = function appendData() {\n      return rewriteTextProtoFunction(this, originalAppendData, arguments);\n    };\n  }\n  if (textProto.insertData) {\n    var originalInsertData = textProto.insertData;\n    textProto.insertData = function insertData() {\n      return rewriteTextProtoFunction(this, originalInsertData, arguments);\n    };\n  }\n  if (textProto.replaceData) {\n    var originalReplaceData = textProto.replaceData;\n    textProto.replaceData = function replaceData() {\n      return rewriteTextProtoFunction(this, originalReplaceData, arguments);\n    };\n  }\n  this.overrideChildNodeInterface(Text, true);\n  // override property getters and setters\n  this.overrideTextProtoGetSet(textProto, 'data');\n  this.overrideTextProtoGetSet(textProto, 'wholeText');\n};\n\n/**\n * Applies attribute getter and setter function overrides to the HTML elements\n * and CSS properties that are URLs are rewritten\n */\nWombat.prototype.initAttrOverrides = function() {\n  // href attr overrides\n  this.overrideHrefAttr(this.$wbwindow.HTMLLinkElement.prototype, 'cs_');\n  this.overrideHrefAttr(this.$wbwindow.CSSStyleSheet.prototype, 'cs_');\n  this.overrideHrefAttr(this.$wbwindow.HTMLBaseElement.prototype, 'mp_');\n  // srcset attr overrides\n  this.overrideSrcsetAttr(this.$wbwindow.HTMLImageElement.prototype, 'im_');\n  this.overrideSrcsetAttr(this.$wbwindow.HTMLSourceElement.prototype, 'oe_');\n  // poster attr overrides\n  this.overrideAttr(this.$wbwindow.HTMLVideoElement.prototype, 'poster', 'im_');\n  this.overrideAttr(this.$wbwindow.HTMLAudioElement.prototype, 'poster', 'im_');\n  // src attr overrides\n  this.overrideAttr(this.$wbwindow.HTMLImageElement.prototype, 'src', 'im_');\n  this.overrideAttr(this.$wbwindow.HTMLInputElement.prototype, 'src', 'oe_');\n  this.overrideAttr(this.$wbwindow.HTMLEmbedElement.prototype, 'src', 'oe_');\n  this.overrideAttr(this.$wbwindow.HTMLMediaElement.prototype, 'src', 'oe_');\n  this.overrideAttr(this.$wbwindow.HTMLVideoElement.prototype, 'src', 'oe_');\n  this.overrideAttr(this.$wbwindow.HTMLAudioElement.prototype, 'src', 'oe_');\n  this.overrideAttr(this.$wbwindow.HTMLSourceElement.prototype, 'src', 'oe_');\n  if (window.HTMLTrackElement && window.HTMLTrackElement.prototype) {\n    this.overrideAttr(this.$wbwindow.HTMLTrackElement.prototype, 'src', 'oe_');\n  }\n  this.overrideAttr(this.$wbwindow.HTMLIFrameElement.prototype, 'src', 'if_');\n  if (\n    this.$wbwindow.HTMLFrameElement &&\n    this.$wbwindow.HTMLFrameElement.prototype\n  ) {\n    this.overrideAttr(this.$wbwindow.HTMLFrameElement.prototype, 'src', 'fr_');\n  }\n  this.overrideAttr(this.$wbwindow.HTMLScriptElement.prototype, 'src', 'js_');\n  // other attr overrides\n  this.overrideAttr(this.$wbwindow.HTMLObjectElement.prototype, 'data', 'oe_');\n  this.overrideAttr(\n    this.$wbwindow.HTMLObjectElement.prototype,\n    'codebase',\n    'oe_'\n  );\n  this.overrideAttr(this.$wbwindow.HTMLMetaElement.prototype, 'content', 'mp_');\n  this.overrideAttr(this.$wbwindow.HTMLFormElement.prototype, 'action', 'mp_');\n  this.overrideAttr(this.$wbwindow.HTMLQuoteElement.prototype, 'cite', 'mp_');\n  this.overrideAttr(this.$wbwindow.HTMLModElement.prototype, 'cite', 'mp_');\n  // a, area tag overrides\n  this.overrideAnchorAreaElem(this.$wbwindow.HTMLAnchorElement);\n  this.overrideAnchorAreaElem(this.$wbwindow.HTMLAreaElement);\n\n  var style_proto = this.$wbwindow.CSSStyleDeclaration.prototype;\n\n  var cssAttrToProps = {\n    'background': 'background',\n    'backgroundImage': 'background-image',\n    'cursor': 'cursor',\n    'listStyle': 'list-style',\n    'listStyleImage': 'list-style-image',\n    'border': 'border',\n    'borderImage': 'border-image',\n    'borderImageSource': 'border-image-source',\n    'maskImage': 'mask-image'\n  };\n\n  this.overrideStyleProxy(Object.values(cssAttrToProps));\n\n  // For FF\n  if (this.$wbwindow.CSS2Properties) {\n    style_proto = this.$wbwindow.CSS2Properties.prototype;\n  }\n\n  this.overrideStyleAttr(style_proto, 'cssText');\n\n  for (var [attr, prop] of Object.entries(cssAttrToProps)) {\n    this.overrideStyleAttr(style_proto, attr, prop);\n  }\n\n  this.overrideStyleSetProp(style_proto);\n\n  if (this.$wbwindow.CSSStyleSheet && this.$wbwindow.CSSStyleSheet.prototype) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule\n    // ruleText is a string of raw css....\n    var wombat = this;\n    var oInsertRule = this.$wbwindow.CSSStyleSheet.prototype.insertRule;\n    this.$wbwindow.CSSStyleSheet.prototype.insertRule = function insertRule(\n      ruleText,\n      index\n    ) {\n      return oInsertRule.call(this, wombat.rewriteStyle(ruleText), index);\n    };\n  }\n\n  if (this.$wbwindow.CSSRule && this.$wbwindow.CSSRule.prototype) {\n    this.overrideStyleAttr(this.$wbwindow.CSSRule.prototype, 'cssText');\n  }\n};\n\n/**\n * Applies overrides to CSSStyleValue.[parse,parseAll], CSSKeywordValue, and\n * StylePropertyMap in order to ensure the URLs these interfaces operate on\n * are rewritten. Gotta love Chrome.\n * @see https://drafts.css-houdini.org/css-typed-om-1/\n */\nWombat.prototype.initCSSOMOverrides = function() {\n  var wombat = this;\n  if (this.$wbwindow.CSSStyleValue) {\n    var cssStyleValueOverride = function(CSSSV, which) {\n      var oFN = CSSSV[which];\n      CSSSV[which] = function parseOrParseAllOverride(property, cssText) {\n        if (cssText == null) return oFN.call(this, property, cssText);\n        var rwCSSText = wombat.noExceptRewriteStyle(cssText);\n        return oFN.call(this, property, rwCSSText);\n      };\n    };\n\n    if (\n      this.$wbwindow.CSSStyleValue.parse &&\n      this.$wbwindow.CSSStyleValue.parse.toString().indexOf('[native code]') > 0\n    ) {\n      cssStyleValueOverride(this.$wbwindow.CSSStyleValue, 'parse');\n    }\n\n    if (\n      this.$wbwindow.CSSStyleValue.parseAll &&\n      this.$wbwindow.CSSStyleValue.parseAll\n        .toString()\n        .indexOf('[native code]') > 0\n    ) {\n      cssStyleValueOverride(this.$wbwindow.CSSStyleValue, 'parseAll');\n    }\n  }\n\n  if (\n    this.$wbwindow.CSSKeywordValue &&\n    this.$wbwindow.CSSKeywordValue.prototype\n  ) {\n    var oCSSKV = this.$wbwindow.CSSKeywordValue;\n    this.$wbwindow.CSSKeywordValue = (function(CSSKeywordValue_) {\n      return function CSSKeywordValue(cssValue) {\n        wombat.domConstructorErrorChecker(this, 'CSSKeywordValue', arguments);\n        return new CSSKeywordValue_(wombat.rewriteStyle(cssValue));\n      };\n    })(this.$wbwindow.CSSKeywordValue);\n    this.$wbwindow.CSSKeywordValue.prototype = oCSSKV.prototype;\n    Object.defineProperty(\n      this.$wbwindow.CSSKeywordValue.prototype,\n      'constructor',\n      {\n        value: this.$wbwindow.CSSKeywordValue\n      }\n    );\n    (0,_wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.addToStringTagToClass)(this.$wbwindow.CSSKeywordValue, 'CSSKeywordValue');\n  }\n\n  if (\n    this.$wbwindow.StylePropertyMap &&\n    this.$wbwindow.StylePropertyMap.prototype\n  ) {\n    var originalSet = this.$wbwindow.StylePropertyMap.prototype.set;\n    this.$wbwindow.StylePropertyMap.prototype.set = function set() {\n      if (arguments.length <= 1) {\n        if (originalSet.__WB_orig_apply) {\n          return originalSet.__WB_orig_apply(this, arguments);\n        }\n        return originalSet.apply(this, arguments);\n      }\n      var newArgs = new Array(arguments.length);\n      newArgs[0] = arguments[0];\n      for (var i = 1; i < arguments.length; i++) {\n        newArgs[i] = wombat.noExceptRewriteStyle(arguments[i]);\n      }\n      if (originalSet.__WB_orig_apply) {\n        return originalSet.__WB_orig_apply(this, newArgs);\n      }\n      return originalSet.apply(this, newArgs);\n    };\n\n    var originalAppend = this.$wbwindow.StylePropertyMap.prototype.append;\n    this.$wbwindow.StylePropertyMap.prototype.append = function append() {\n      if (arguments.length <= 1) {\n        if (originalSet.__WB_orig_apply) {\n          return originalAppend.__WB_orig_apply(this, arguments);\n        }\n        return originalAppend.apply(this, arguments);\n      }\n      var newArgs = new Array(arguments.length);\n      newArgs[0] = arguments[0];\n      for (var i = 1; i < arguments.length; i++) {\n        newArgs[i] = wombat.noExceptRewriteStyle(arguments[i]);\n      }\n      if (originalAppend.__WB_orig_apply) {\n        return originalAppend.__WB_orig_apply(this, newArgs);\n      }\n      return originalAppend.apply(this, newArgs);\n    };\n  }\n};\n\n/**\n * Applies an overrides to the Audio constructor in order to ensure its URL\n * argument is rewritten\n */\nWombat.prototype.initAudioOverride = function() {\n  if (!this.$wbwindow.Audio) return;\n  var orig_audio = this.$wbwindow.Audio;\n  var wombat = this;\n  this.$wbwindow.Audio = (function(Audio_) {\n    return function Audio(url) {\n      wombat.domConstructorErrorChecker(this, 'Audio');\n      return new Audio_(wombat.rewriteUrl(url, true, 'oe_'));\n    };\n  })(this.$wbwindow.Audio);\n\n  this.$wbwindow.Audio.prototype = orig_audio.prototype;\n  Object.defineProperty(this.$wbwindow.Audio.prototype, 'constructor', {\n    value: this.$wbwindow.Audio\n  });\n  (0,_wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.addToStringTagToClass)(this.$wbwindow.Audio, 'HTMLAudioElement');\n};\n\n/**\n * Initializes the BAD_PREFIXES array using the supplied prefix\n * @param {string} prefix\n */\nWombat.prototype.initBadPrefixes = function(prefix) {\n  this.BAD_PREFIXES = [\n    'http:' + prefix,\n    'https:' + prefix,\n    'http:/' + prefix,\n    'https:/' + prefix\n  ];\n};\n\n/**\n * Applies an override to crypto.getRandomValues in order to make\n * the values it returns are deterministic during replay\n */\nWombat.prototype.initCryptoRandom = function() {\n  if (!this.$wbwindow.crypto || !this.$wbwindow.Crypto) return;\n  var wombat = this;\n  var new_getrandom = function getRandomValues(array) {\n    for (var i = 0; i < array.length; i++) {\n      array[i] = parseInt(wombat.$wbwindow.Math.random() * 4294967296);\n    }\n    return array;\n  };\n  this.$wbwindow.Crypto.prototype.getRandomValues = new_getrandom;\n  this.$wbwindow.crypto.getRandomValues = new_getrandom;\n};\n\n/**\n * Applies an override to the Date object in order to ensure that\n * all Dates used during replay are in the datetime of replay\n * @param {string} timestamp\n */\nWombat.prototype.initDateOverride = function(timestamp) {\n  if (this.$wbwindow.__wb_Date_now) return;\n  var newTimestamp = parseInt(timestamp) * 1000;\n  // var timezone = new Date().getTimezoneOffset() * 60 * 1000;\n  // Already UTC!\n  var timezone = 0;\n  var start_now = this.$wbwindow.Date.now();\n  var timediff = start_now - (newTimestamp - timezone);\n\n  var orig_date = this.$wbwindow.Date;\n\n  var orig_utc = this.$wbwindow.Date.UTC;\n  var orig_parse = this.$wbwindow.Date.parse;\n  var orig_now = this.$wbwindow.Date.now;\n\n  this.$wbwindow.__wb_Date_now = orig_now;\n\n  this.$wbwindow.Date = (function(Date_) {\n    return function Date(A, B, C, D, E, F, G) {\n      // [native code]\n      // Apply doesn't work for constructors and Date doesn't\n      // seem to like undefined args, so must explicitly\n      // call constructor for each possible args 0..7\n      if (A === undefined) {\n        return new Date_(orig_now() - timediff);\n      } else if (B === undefined) {\n        return new Date_(A);\n      } else if (C === undefined) {\n        return new Date_(A, B);\n      } else if (D === undefined) {\n        return new Date_(A, B, C);\n      } else if (E === undefined) {\n        return new Date_(A, B, C, D);\n      } else if (F === undefined) {\n        return new Date_(A, B, C, D, E);\n      } else if (G === undefined) {\n        return new Date_(A, B, C, D, E, F);\n      } else {\n        return new Date_(A, B, C, D, E, F, G);\n      }\n    };\n  })(this.$wbwindow.Date);\n\n  this.$wbwindow.Date.prototype = orig_date.prototype;\n\n  this.$wbwindow.Date.now = function now() {\n    return orig_now() - timediff;\n  };\n\n  this.$wbwindow.Date.UTC = orig_utc;\n  this.$wbwindow.Date.parse = orig_parse;\n\n  this.$wbwindow.Date.__WB_timediff = timediff;\n\n  this.$wbwindow.Date.prototype.getTimezoneOffset = function() {\n    return 0;\n  };\n\n  var orig_toString = this.$wbwindow.Date.prototype.toString;\n  this.$wbwindow.Date.prototype.toString = function() {\n    var string = orig_toString.call(this).split(' GMT')[0];\n    return string + ' GMT+0000 (Coordinated Universal Time)';\n  };\n\n  var orig_toTimeString = this.$wbwindow.Date.prototype.toTimeString;\n  this.$wbwindow.Date.prototype.toTimeString = function() {\n    var string = orig_toTimeString.call(this).split(' GMT')[0];\n    return string + ' GMT+0000 (Coordinated Universal Time)';\n  };\n\n  Object.defineProperty(this.$wbwindow.Date.prototype, 'constructor', {\n    value: this.$wbwindow.Date\n  });\n};\n\n\nWombat.prototype.initBlobOverride = function() {\n  // don't use for SW replay as blob: iframes won't have access to SW\n  if (!this.$wbwindow.Blob || this.wb_info.isSW) {\n    return;\n  }\n\n  var orig_blob = this.$wbwindow.Blob;\n\n  var wombat = this;\n\n  this.$wbwindow.Blob = (function(Blob_) {\n    return function Blob(array, options) {\n\n      if (options && (options.type === 'application/xhtml+xml' || options.type === 'text/html')) {\n        // for now, just handle single string case\n        if (array.length === 1 && typeof(array[0]) === 'string' && wombat.startsWith(array[0], '<!DOCTYPE html>')) {\n          array[0] = wombat.rewriteHtml(array[0]);\n          options.type = 'text/html';\n        }\n      }\n\n      return new Blob_(array, options);\n    };\n  })(this.$wbwindow.Blob);\n\n  this.$wbwindow.Blob.prototype = orig_blob.prototype;\n};\n\nWombat.prototype.initWSOverride = function() {\n  if (!this.$wbwindow.WebSocket || !this.$wbwindow.WebSocket.prototype) {\n    return;\n  }\n\n  this.$wbwindow.WebSocket = (function(WebSocket_) {\n    function WebSocket(url, protocols) {\n      this.openCallbacks = [];\n\n      this.addEventListener = function(type, callback) {\n        if (type === \"open\") {\n          WebSocket.openCallbacks.push(callback);\n        }\n      };\n      this.removeEventListener = function() {};\n      this.close = function() {};\n      this.send = function(data) {\n        console.log('ws send', data);\n      };\n\n      this.protocol = protocols && protocols.length ? protocols[0] : '';\n      this.url = url;\n      this.readyState = 1;\n\n      var ws = this;\n      function simOpen() {\n        var ev = new CustomEvent(\"open\");\n        if (ws.onopen) {\n          ws.onopen(ev);\n        }\n        ws.openCallbacks.forEach(callback => callback(ev));\n      }\n\n      setTimeout(simOpen, 500);\n    }\n\n    WebSocket.CONNECTING = 0;\n    WebSocket.OPEN = 1;\n    WebSocket.CLOSING = 2;\n    WebSocket.CLOSED = 3;\n\n    return WebSocket;\n  })(this.$wbwindow.WebSocket);\n\n  Object.defineProperty(this.$wbwindow.WebSocket.prototype, 'constructor', {\n    value: this.$wbwindow.WebSocket\n  });\n\n  (0,_wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.addToStringTagToClass)(this.$wbwindow.WebSocket, 'WebSocket');\n};\n \n/**\n * Applies an override to the document.title property in order to ensure\n * that actual top (archive top frame containing the replay iframe) receives\n * document.title updates\n */\nWombat.prototype.initDocTitleOverride = function() {\n  var orig_get_title = this.getOrigGetter(this.$wbwindow.document, 'title');\n  var orig_set_title = this.getOrigSetter(this.$wbwindow.document, 'title');\n  var wombat = this;\n  var set_title = function title(value) {\n    var res = orig_set_title.call(this, value);\n    var message = { wb_type: 'title', title: value };\n    wombat.sendTopMessage(message);\n    return res;\n  };\n  this.defProp(this.$wbwindow.document, 'title', set_title, orig_get_title);\n};\n\n/**\n * Applies an override to the FontFace constructor in order to ensure font URLs\n * are rewritten\n * @see https://drafts.csswg.org/css-font-loading/#FontFace-interface\n */\nWombat.prototype.initFontFaceOverride = function() {\n  if (!this.$wbwindow.FontFace) {\n    return;\n  }\n  var wombat = this;\n  var origFontFace = this.$wbwindow.FontFace;\n  this.$wbwindow.FontFace = (function(FontFace_) {\n    return function FontFace(family, source, descriptors) {\n      wombat.domConstructorErrorChecker(this, 'FontFace', arguments, 2);\n      var rwSource = source;\n      if (source != null) {\n        if (typeof source !== 'string') {\n          // is CSSOMString or ArrayBuffer or ArrayBufferView\n          rwSource = wombat.rewriteInlineStyle(source.toString());\n        } else {\n          rwSource = wombat.rewriteInlineStyle(source);\n        }\n      }\n      return new FontFace_(family, rwSource, descriptors);\n    };\n  })(this.$wbwindow.FontFace);\n  this.$wbwindow.FontFace.prototype = origFontFace.prototype;\n  Object.defineProperty(this.$wbwindow.FontFace.prototype, 'constructor', {\n    value: this.$wbwindow.FontFace\n  });\n  (0,_wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.addToStringTagToClass)(this.$wbwindow.FontFace, 'FontFace');\n};\n\n/**\n * Forces, when possible, the devicePixelRatio property of window to 1\n * in order to ensure deterministic replay\n */\nWombat.prototype.initFixedRatio = function(value) {\n  try {\n    // otherwise, just set it\n    this.$wbwindow.devicePixelRatio = value;\n  } catch (e) {}\n\n  // prevent changing, if possible\n  if (Object.defineProperty) {\n    try {\n      // fixed pix ratio\n      Object.defineProperty(this.$wbwindow, 'devicePixelRatio', {\n        value: value,\n        writable: false\n      });\n    } catch (e) {}\n  }\n};\n\n/**\n * Initializes wombats path information from the supplied wbinfo object\n * @param {Object} wbinfo\n */\nWombat.prototype.initPaths = function(wbinfo) {\n  wbinfo.wombat_opts = wbinfo.wombat_opts || {};\n  //this.wb_info = wbinfo;\n  Object.assign(this.wb_info, wbinfo);\n  this.wb_opts = wbinfo.wombat_opts;\n  this.wb_replay_prefix = wbinfo.prefix;\n  this.wb_is_proxy = wbinfo.proxy_magic || !this.wb_replay_prefix;\n  this.wb_info.top_host = this.wb_info.top_host || '*';\n  this.wb_curr_host =\n    this.$wbwindow.location.protocol + '//' + this.$wbwindow.location.host;\n  this.wb_info.wombat_opts = this.wb_info.wombat_opts || {};\n  this.wb_orig_scheme = wbinfo.wombat_scheme + '://';\n  this.wb_orig_origin = this.wb_orig_scheme + wbinfo.wombat_host;\n  this.wb_abs_prefix = this.wb_replay_prefix;\n  if (!wbinfo.is_live && wbinfo.wombat_ts) {\n    this.wb_capture_date_part = '/' + wbinfo.wombat_ts + '/';\n  } else {\n    this.wb_capture_date_part = '';\n  }\n  this.initBadPrefixes(this.wb_replay_prefix);\n  this.initCookiePreset();\n};\n\n/**\n * Applies an override to Math.seed and Math.random using the supplied\n * seed in order to ensure that random numbers are deterministic during\n * replay\n * @param {string} seed\n */\nWombat.prototype.initSeededRandom = function(seed) {\n  // Adapted from:\n  // http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n  this.$wbwindow.Math.seed = parseInt(seed);\n  var wombat = this;\n  this.$wbwindow.Math.random = function random() {\n    wombat.$wbwindow.Math.seed =\n      (wombat.$wbwindow.Math.seed * 9301 + 49297) % 233280;\n    return wombat.$wbwindow.Math.seed / 233280;\n  };\n};\n\n/**\n * Applies overrides to history.pushState and history.replaceState in order\n * to ensure that URLs used for browser history manipulation are rewritten.\n * Also adds a `popstate` listener to window of the browser context wombat is in\n * in order to ensure that actual top (archive top frame containing the replay iframe)\n * browser history is updated IFF the history manipulation happens in the replay top\n */\nWombat.prototype.initHistoryOverrides = function() {\n  this.overrideHistoryFunc('pushState');\n  this.overrideHistoryFunc('replaceState');\n  var wombat = this;\n  this.$wbwindow.addEventListener('popstate', function(event) {\n    wombat.sendHistoryUpdate(\n      wombat.$wbwindow.WB_wombat_location.href,\n      wombat.$wbwindow.document.title\n    );\n  });\n};\n\n/**\n * If cookie preset if passed in via wb_info, set parse and set cookies on the document\n */\nWombat.prototype.initCookiePreset = function() {\n  if (this.wb_info.presetCookie) {\n    var splitCookies = this.wb_info.presetCookie.split(';');\n    for (var i = 0; i < splitCookies.length; i++) {\n      this.$wbwindow.document.cookie = splitCookies[i].trim() + '; Path=' + this.rewriteUrl('./', true);\n    }\n  }\n};\n\n/**\n * Applies overrides to the XMLHttpRequest.open and XMLHttpRequest.responseURL\n * in order to ensure URLs are rewritten.\n *\n * Applies an override to window.fetch in order to rewrite URLs and URLs of\n * the supplied Request objects used as arguments to fetch.\n *\n * Applies overrides to window.Request, window.Response, window.EventSource,\n * and window.WebSocket in order to ensure URLs they operate on are rewritten.\n *\n * @see https://xhr.spec.whatwg.org/\n * @see https://fetch.spec.whatwg.org/\n * @see https://html.spec.whatwg.org/multipage/web-sockets.html#websocket\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n */\nWombat.prototype.initHTTPOverrides = function() {\n  var wombat = this;\n\n    // responseURL override\n  this.overridePropExtract(this.$wbwindow.XMLHttpRequest.prototype, 'responseURL');\n\n  if (!this.wb_info.isSW) {\n    if (this.$wbwindow.XMLHttpRequest.prototype.open) {\n      var origXMLHttpOpen = this.$wbwindow.XMLHttpRequest.prototype.open;\n      this.utilFns.XHRopen = origXMLHttpOpen;\n      this.utilFns.XHRsend = this.$wbwindow.XMLHttpRequest.prototype.send;\n      this.$wbwindow.XMLHttpRequest.prototype.open = function open(\n        method,\n        url,\n        async,\n        user,\n        password\n      ) {\n        var rwURL = !this._no_rewrite ? wombat.rewriteUrl(url) : url;\n        var openAsync = true;\n        if (async != null && !async) openAsync = false;\n        origXMLHttpOpen.call(this, method, rwURL, openAsync, user, password);\n        if (!wombat.startsWith(rwURL, 'data:')) {\n          this.setRequestHeader('X-Pywb-Requested-With', 'XMLHttpRequest');\n        }\n      };\n    }\n  } else {\n    var origOpen = this.$wbwindow.XMLHttpRequest.prototype.open;\n    var origSetRequestHeader = this.$wbwindow.XMLHttpRequest.prototype.setRequestHeader;\n    var origSend = this.$wbwindow.XMLHttpRequest.prototype.send;\n    this.utilFns.XHRopen = origOpen;\n    this.utilFns.XHRsend = origSend;\n\n    this.$wbwindow.XMLHttpRequest.prototype.open = function() {\n      this.__WB_xhr_open_arguments = arguments;\n      this.__WB_xhr_headers = new Headers();\n    };\n\n    this.$wbwindow.XMLHttpRequest.prototype.setRequestHeader = function(name, value) {\n      this.__WB_xhr_headers.set(name, value);\n    };\n\n    var wombat = this;\n    var convertToGet = !!this.wb_info.convert_post_to_get;\n\n    this.$wbwindow.XMLHttpRequest.prototype.send = async function(value) {\n      if (convertToGet && (this.__WB_xhr_open_arguments[0] === 'POST' || this.__WB_xhr_open_arguments[0] === 'PUT')) {\n\n        var request = {\n          'url': this.__WB_xhr_open_arguments[1],\n          'method': this.__WB_xhr_open_arguments[0],\n          'headers': this.__WB_xhr_headers,\n          'postData': value\n        };\n\n        if ((0,warcio_utils__WEBPACK_IMPORTED_MODULE_6__.postToGetUrl)(request)) {\n          this.__WB_xhr_open_arguments[1] = request.url;\n          this.__WB_xhr_open_arguments[0] = 'GET';\n          value = null;\n        }\n      }\n\n      if (!this._no_rewrite) {\n        this.__WB_xhr_open_arguments[1] = wombat.rewriteUrl(this.__WB_xhr_open_arguments[1]);\n      }\n\n      // sync mode: disable unless Firefox\n      // sync xhr with service workers supported only in FF at the moment\n      // https://wpt.fyi/results/service-workers/service-worker/fetch-request-xhr-sync.https.html\n      if (this.__WB_xhr_open_arguments.length > 2 && !this.__WB_xhr_open_arguments[2] && navigator.userAgent.indexOf('Firefox') === -1) {\n        this.__WB_xhr_open_arguments[2] = true;\n        console.warn('wombat.js: Sync XHR not supported in SW-based replay in this browser, attempting load via iframe');\n\n        function loadSync(url) {\n          var elem = document.createElement('iframe');\n          var text = '';\n\n          elem.style = 'display: none';\n          elem.src = url;\n          elem._no_rewrite = true;\n\n          document.body.appendChild(elem);\n\n          for (var i = 0; i < 20000; i++) {\n            if (elem.contentDocument && elem.contentDocument.body) {\n              elem.contentDocument.body._no_rewrite = true;\n              text = elem.contentDocument.body.innerText;\n              break;\n            }\n          }\n\n          document.body.removeChild(elem);\n          return text;\n        }\n\n        this.responseText = loadSync(this.__WB_xhr_open_arguments[1]);\n        return;\n      }\n\n      origOpen.apply(this, this.__WB_xhr_open_arguments);\n\n      if (!wombat.startsWith(this.__WB_xhr_open_arguments[1], 'data:')) {\n        for (const [name, value] of this.__WB_xhr_headers.entries()) {\n          origSetRequestHeader.call(this, name, value);\n        }\n\n        origSetRequestHeader.call(this, 'X-Pywb-Requested-With', 'XMLHttpRequest');\n      }\n\n      return origSend.call(this, value);\n    };\n  }\n\n  if (this.$wbwindow.fetch) {\n    var orig_fetch = this.$wbwindow.fetch;\n    this.$wbwindow.fetch = function fetch(input, init_opts) {\n      var rwInput = input;\n      var inputType = typeof input;\n      if (inputType === 'string') {\n        rwInput = wombat.rewriteUrl(input);\n      } else if (inputType === 'object' && input.url) {\n        var new_url = wombat.rewriteUrl(input.url);\n        if (new_url !== input.url) {\n          rwInput = new Request(new_url, init_opts);\n        }\n      } else if (inputType === 'object' && input.href) {\n        // it is likely that input is either window.location or window.URL\n        rwInput = wombat.rewriteUrl(input.href);\n      }\n\n      if (!init_opts) {\n        init_opts = {};\n      }\n      if (init_opts.credentials === undefined) {\n        try {\n          init_opts.credentials = 'include';\n        } catch(e) {}\n      }\n\n      return orig_fetch.call(wombat.proxyToObj(this), rwInput, init_opts);\n    };\n  }\n\n  if (this.$wbwindow.Request && this.$wbwindow.Request.prototype) {\n    var orig_request = this.$wbwindow.Request;\n    this.$wbwindow.Request = (function(Request_) {\n      return function Request(input, init_opts) {\n        wombat.domConstructorErrorChecker(this, 'Request', arguments);\n        var newInitOpts = init_opts || {};\n        var newInput = input;\n        var inputType = typeof input;\n        switch (inputType) {\n          case 'string':\n            newInput = wombat.rewriteUrl(input);\n            break;\n          case 'object':\n            newInput = input;\n            if (input.url) {\n              var new_url = wombat.rewriteUrl(input.url);\n              if (new_url !== input.url) {\n                // not much we can do here Request.url is read only\n                // https://developer.mozilla.org/en-US/docs/Web/API/Request/url\n                newInput = new Request_(new_url, input);\n              }\n            } else if (input.href) {\n              // it is likely that input is either window.location or window.URL\n              newInput = wombat.rewriteUrl(input.toString(), true);\n            }\n            break;\n        }\n        newInitOpts['credentials'] = 'include';\n        if (newInitOpts.referrer) {\n          newInitOpts.referrer = wombat.rewriteUrl(newInitOpts.referrer);\n        }\n\n        return new Request_(newInput, newInitOpts);\n      };\n    })(this.$wbwindow.Request);\n\n    this.$wbwindow.Request.prototype = orig_request.prototype;\n    Object.defineProperty(this.$wbwindow.Request.prototype, 'constructor', {\n      value: this.$wbwindow.Request\n    });\n\n    // override Request.url\n    this.overridePropExtract(this.$wbwindow.Request.prototype, 'url');\n\n    // override Request.referrer\n    this.overridePropExtract(this.$wbwindow.Request.prototype, 'referrer');\n  }\n\n  if (this.$wbwindow.Response && this.$wbwindow.Response.prototype) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Response/redirect\n    var originalRedirect = this.$wbwindow.Response.prototype.redirect;\n    this.$wbwindow.Response.prototype.redirect = function redirect(\n      url,\n      status\n    ) {\n      var rwURL = wombat.rewriteUrl(url, true, null, wombat.$wbwindow.document);\n      return originalRedirect.call(this, rwURL, status);\n    };\n\n    // override Response.url\n    this.overridePropExtract(this.$wbwindow.Response.prototype, 'url');\n  }\n\n  if (this.$wbwindow.EventSource && this.$wbwindow.EventSource.prototype) {\n    var origEventSource = this.$wbwindow.EventSource;\n    this.$wbwindow.EventSource = (function(EventSource_) {\n      return function EventSource(url, configuration) {\n        wombat.domConstructorErrorChecker(this, 'EventSource', arguments);\n        var rwURL = url;\n        if (url != null) {\n          rwURL = wombat.rewriteUrl(url);\n        }\n        return new EventSource_(rwURL, configuration);\n      };\n    })(this.$wbwindow.EventSource);\n    this.$wbwindow.EventSource.prototype = origEventSource.prototype;\n    Object.defineProperty(this.$wbwindow.EventSource.prototype, 'constructor', {\n      value: this.$wbwindow.EventSource\n    });\n    (0,_wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.addToStringTagToClass)(this.$wbwindow.EventSource, 'EventSource');\n  }\n};\n\n/**\n * Applies an override to Element.[getAttribute, setAttribute] in order to\n * ensure that operations on properties that contain URLs are rewritten\n * @see https://www.w3.org/TR/dom/#interface-element\n */\nWombat.prototype.initElementGetSetAttributeOverride = function() {\n  if (\n    this.wb_opts.skip_setAttribute ||\n    (!this.$wbwindow.Element || !this.$wbwindow.Element.prototype)\n  ) {\n    return;\n  }\n\n  var wombat = this;\n  var ElementProto = this.$wbwindow.Element.prototype;\n\n  if (ElementProto.setAttribute) {\n    var orig_setAttribute = ElementProto.setAttribute;\n    ElementProto._orig_setAttribute = orig_setAttribute;\n    ElementProto.setAttribute = function setAttribute(name, value) {\n      var rwValue = value;\n      if (name && typeof rwValue === 'string') {\n        var lowername = name.toLowerCase();\n        if (\n          this.tagName === 'LINK' &&\n          lowername === 'href' &&\n          rwValue.indexOf('data:text/css') === 0\n        ) {\n          rwValue = wombat.rewriteInlineStyle(value);\n        } else if (lowername === 'style') {\n          rwValue = wombat.rewriteStyle(value);\n        } else if (lowername === 'srcset' || (lowername === 'imagesrcset' && this.tagName === 'LINK')) {\n          rwValue = wombat.rewriteSrcset(value, this);\n        } else {\n          var shouldRW = wombat.shouldRewriteAttr(this.tagName, lowername);\n          if (shouldRW) {\n            wombat.removeWBOSRC(this);\n            if (!this._no_rewrite) {\n              rwValue = wombat.rewriteUrl(\n                value,\n                false,\n                wombat.rwModForElement(this, lowername)\n              );\n            }\n          }\n        }\n      }\n      return orig_setAttribute.call(this, name, rwValue);\n    };\n  }\n\n  if (ElementProto.getAttribute) {\n    var orig_getAttribute = ElementProto.getAttribute;\n    this.wb_getAttribute = orig_getAttribute;\n    ElementProto.getAttribute = function getAttribute(name) {\n      var result = orig_getAttribute.call(this, name);\n      if (result === null) {\n        return result;\n      }\n      var lowerName = name;\n      if (name) {\n        lowerName = name.toLowerCase();\n      }\n      if (wombat.shouldRewriteAttr(this.tagName, lowerName)) {\n        var maybeWBOSRC = wombat.retrieveWBOSRC(this);\n        if (maybeWBOSRC) return maybeWBOSRC;\n        return wombat.extractOriginalURL(result);\n      } else if (\n        wombat.startsWith(lowerName, 'data-') &&\n        wombat.startsWithOneOf(result, wombat.wb_prefixes)\n      ) {\n        return wombat.extractOriginalURL(result);\n      }\n\n      return result;\n    };\n  }\n};\n\n/**\n * Applies an override to the getAttribute[NS] and setAttribute[NS] functions\n * of the SVGImageElement interface in order to ensure that the URLs of the\n * href and xlink:href properties are rewritten\n */\nWombat.prototype.initSvgImageOverrides = function() {\n  if (!this.$wbwindow.SVGImageElement) {\n    return;\n  }\n  var svgImgProto = this.$wbwindow.SVGImageElement.prototype;\n\n  var orig_getAttr = svgImgProto.getAttribute;\n  var orig_getAttrNS = svgImgProto.getAttributeNS;\n  var orig_setAttr = svgImgProto.setAttribute;\n  var orig_setAttrNS = svgImgProto.setAttributeNS;\n  var wombat = this;\n\n  svgImgProto.getAttribute = function getAttribute(name) {\n    var value = orig_getAttr.call(this, name);\n    if (name.indexOf('xlink:href') >= 0 || name === 'href') {\n      return wombat.extractOriginalURL(value);\n    }\n    return value;\n  };\n\n  svgImgProto.getAttributeNS = function getAttributeNS(ns, name) {\n    var value = orig_getAttrNS.call(this, ns, name);\n    if (name.indexOf('xlink:href') >= 0 || name === 'href') {\n      return wombat.extractOriginalURL(value);\n    }\n    return value;\n  };\n\n  svgImgProto.setAttribute = function setAttribute(name, value) {\n    var rwValue = value;\n    if (name.indexOf('xlink:href') >= 0 || name === 'href') {\n      rwValue = wombat.rewriteUrl(value);\n    }\n    return orig_setAttr.call(this, name, rwValue);\n  };\n\n  svgImgProto.setAttributeNS = function setAttributeNS(ns, name, value) {\n    var rwValue = value;\n    if (name.indexOf('xlink:href') >= 0 || name === 'href') {\n      rwValue = wombat.rewriteUrl(value);\n    }\n    return orig_setAttrNS.call(this, ns, name, rwValue);\n  };\n};\n\n/**\n * Applies an override to document.createElementNS in order to ensure that the\n * nameSpaceURI argument is un-rewritten\n */\nWombat.prototype.initCreateElementNSFix = function() {\n  if (\n    !this.$wbwindow.document.createElementNS ||\n    !this.$wbwindow.Document.prototype.createElementNS\n  ) {\n    return;\n  }\n  var orig_createElementNS = this.$wbwindow.document.createElementNS;\n  var wombat = this;\n\n  var createElementNS = function createElementNS(namespaceURI, qualifiedName) {\n    return orig_createElementNS.call(\n      wombat.proxyToObj(this),\n      wombat.extractOriginalURL(namespaceURI),\n      qualifiedName\n    );\n  };\n\n  this.$wbwindow.Document.prototype.createElementNS = createElementNS;\n  this.$wbwindow.document.createElementNS = createElementNS;\n};\n\n/**\n * Applies an override to Element.insertAdjacentHTML in order to ensure\n * that the strings of HTML to be inserted are rewritten and to\n * Element.insertAdjacentElement in order to ensure that the Elements to\n * be inserted are rewritten\n */\nWombat.prototype.initInsertAdjacentElementHTMLOverrides = function() {\n  var Element = this.$wbwindow.Element;\n  if (!Element || !Element.prototype) return;\n  var elementProto = Element.prototype;\n  var rewriteFn = this.rewriteInsertAdjHTMLOrElemArgs;\n  if (elementProto.insertAdjacentHTML) {\n    var origInsertAdjacentHTML = elementProto.insertAdjacentHTML;\n    elementProto.insertAdjacentHTML = function insertAdjacentHTML(\n      position,\n      text\n    ) {\n      return rewriteFn(this, origInsertAdjacentHTML, position, text, true);\n    };\n  }\n  if (elementProto.insertAdjacentElement) {\n    var origIAdjElem = elementProto.insertAdjacentElement;\n    elementProto.insertAdjacentElement = function insertAdjacentElement(\n      position,\n      element\n    ) {\n      return rewriteFn(this, origIAdjElem, position, element, false);\n    };\n  }\n};\n\n/**\n * Applies overrides to Node.[appendChild, insertBefore, replaceChild] and\n * [Element, DocumentFragment].[append, prepend) in order to ensure the that\n * the elements added by these functions are rewritten.\n * Also applies an override to the Node.ownerDocument, HTMLHtmlElement.parentNode,\n * and Event.target getter functions do not return a JS Proxy object used by wombat\n * @see https://www.w3.org/TR/dom/#node\n */\nWombat.prototype.initDomOverride = function() {\n  var Node = this.$wbwindow.Node;\n  if (Node && Node.prototype) {\n    var rewriteFn = this.rewriteNodeFuncArgs;\n    if (Node.prototype.appendChild) {\n      var originalAppendChild = Node.prototype.appendChild;\n      Node.prototype.appendChild = function appendChild(newNode, oldNode) {\n        return rewriteFn(this, originalAppendChild, newNode, oldNode);\n      };\n    }\n    if (Node.prototype.insertBefore) {\n      var originalInsertBefore = Node.prototype.insertBefore;\n      Node.prototype.insertBefore = function insertBefore(newNode, oldNode) {\n        return rewriteFn(this, originalInsertBefore, newNode, oldNode);\n      };\n    }\n    if (Node.prototype.replaceChild) {\n      var originalReplaceChild = Node.prototype.replaceChild;\n      Node.prototype.replaceChild = function replaceChild(newNode, oldNode) {\n        return rewriteFn(this, originalReplaceChild, newNode, oldNode);\n      };\n    }\n    this.overridePropToProxy(Node.prototype, 'ownerDocument');\n    this.overridePropToProxy(\n      this.$wbwindow.HTMLHtmlElement.prototype,\n      'parentNode'\n    );\n    this.overridePropToProxy(this.$wbwindow.Event.prototype, 'target');\n  }\n\n  if (this.$wbwindow.Element && this.$wbwindow.Element.prototype) {\n    this.overrideParentNodeAppendPrepend(this.$wbwindow.Element);\n    this.overrideChildNodeInterface(this.$wbwindow.Element, false);\n  }\n\n  if (\n    this.$wbwindow.DocumentFragment &&\n    this.$wbwindow.DocumentFragment.prototype\n  ) {\n    this.overrideParentNodeAppendPrepend(this.$wbwindow.DocumentFragment);\n  }\n};\n\n/**\n * Applies overrides to document.referrer, document.origin, document.domain, and\n * window.origin in order to ensure their getters and setters behave as expected\n * on the live web\n * @param {Document} $document\n */\nWombat.prototype.initDocOverrides = function($document) {\n  if (!Object.defineProperty) return;\n\n  // referrer\n  this.overrideReferrer($document);\n\n  // origin\n  this.defGetterProp($document, 'origin', function origin() {\n    return this.WB_wombat_location.origin;\n  });\n  // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/origin, chrome 59+ and ff 54+\n  this.defGetterProp(this.$wbwindow, 'origin', function origin() {\n    return this.WB_wombat_location.origin;\n  });\n\n  var wombat = this;\n  // domain\n  var domain_setter = function domain(val) {\n    var loc = this.WB_wombat_location;\n    if (loc && wombat.endsWith(loc.hostname, val)) {\n      this.__wb_domain = val;\n    }\n  };\n\n  var domain_getter = function domain() {\n    return this.__wb_domain || this.WB_wombat_location.hostname;\n  };\n\n  this.defProp($document, 'domain', domain_setter, domain_getter);\n};\n\n/**\n * Apples overrides to document.[write, writeln, open, close] in order\n * to ensure that the values they operate on or create are rewritten and\n * wombat is initialized in the new documents/windows.\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-document-open-window\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-document-close\n * @see https://html.spec.whatwg.org/multipage/dom.html#dom-document-body\n */\nWombat.prototype.initDocWriteOpenCloseOverride = function() {\n  if (!this.$wbwindow.DOMParser) {\n    return;\n  }\n\n  // for both document.write and document.writeln, all arguments are treated as a string and concatenated together\n  // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html\n\n  var DocumentProto = this.$wbwindow.Document.prototype;\n  var $wbDocument = this.$wbwindow.document;\n\n  this._writeBuff = '';\n\n  var wombat = this;\n\n  function isSWLoad() {\n    return wombat.wb_info.isSW && wombat.$wbwindow.frameElement;\n  }\n\n  function prepForWrite(args) {\n    var string;\n\n    if (args.length === 0) {\n      return '';\n    }\n\n    if (args.length === 1) {\n      string = args[0];\n    } else {\n      // use Array.join rather than Array.apply because join works with array like objects\n      string = Array.prototype.join.call(args, '');\n    }\n\n    return string;\n  }\n\n  /**\n   * Rewrite the arguments supplied to document.[write, writeln] in order\n   * to ensure that the string of HTML is rewritten\n   * @param {Object} fnThis\n   * @param {function} originalFn\n   * @param {Object} rewritten string\n   */\n  function docWrite(fnThis, originalFn, string) {\n    var win = wombat.$wbwindow;\n\n    if (isSWLoad() || (document.readyState === 'loading' && wombat.wb_info.injectDocClose)) {\n      wombat._writeBuff += string;\n      return;\n    }\n\n    string = wombat.rewriteHtml(string, true);\n    var thisObj = wombat.proxyToObj(fnThis);\n    var res = originalFn.call(thisObj, string);\n    wombat.initNewWindowWombat(thisObj.defaultView);\n    return res;\n  };\n\n  // Write\n  var orig_doc_write = $wbDocument.write;\n  var new_write = function write() {\n    return docWrite(this, orig_doc_write, prepForWrite(arguments));\n  };\n  $wbDocument.write = new_write;\n  DocumentProto.write = new_write;\n\n  // Writeln\n  var orig_doc_writeln = $wbDocument.writeln;\n  var new_writeln = function writeln() {\n    return docWrite(this, orig_doc_writeln, prepForWrite(arguments));\n  };\n  $wbDocument.writeln = new_writeln;\n  DocumentProto.writeln = new_writeln;\n\n  // Open\n  var orig_doc_open = $wbDocument.open;\n  var new_open = function open() {\n    var thisObj = wombat.proxyToObj(this);\n    var res;\n    if (arguments.length === 3) {\n      // we have the case where a new window will be opened\n      // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-document-open-window\n      var rwUrl = wombat.rewriteUrl(arguments[0], false, 'mp_');\n      res = orig_doc_open.call(thisObj, rwUrl, arguments[1], arguments[2]);\n      wombat.initNewWindowWombat(res, arguments[0]);\n    } else {\n      res = orig_doc_open.call(thisObj);\n      if (isSWLoad()) {\n        wombat._writeBuff = '';\n      } else {\n        wombat.initNewWindowWombat(thisObj.defaultView);\n      }\n    }\n    return res;\n  };\n\n  $wbDocument.open = new_open;\n  DocumentProto.open = new_open;\n\n  // we override close in order to ensure wombat is init'd\n  // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-document-close\n  var originalClose = $wbDocument.close;\n  var newClose = function close() {\n    if (wombat._writeBuff) {\n      if (isSWLoad()) {\n        wombat.blobUrlForIframe(wombat.$wbwindow.frameElement, wombat._writeBuff);\n      } else if (document.readyState === 'loading') {\n        orig_doc_write.call($wbDocument, wombat.rewriteHtml(wombat._writeBuff, true));\n      }\n      wombat._writeBuff = '';\n      return;\n    }\n    var thisObj = wombat.proxyToObj(this);\n    wombat.initNewWindowWombat(thisObj.defaultView);\n    if (originalClose.__WB_orig_apply) {\n      return originalClose.__WB_orig_apply(thisObj, arguments);\n    }\n    return originalClose.apply(thisObj, arguments);\n  };\n\n  $wbDocument.close = newClose;\n  DocumentProto.close = newClose;\n\n  // we override the setter for document.body because it is settable\n  // to either an instance of HTMLBodyElement or HTMLFrameSetElement and\n  // there are ways to get un-rewritten elements into replay we must allow\n  // https://html.spec.whatwg.org/multipage/dom.html#dom-document-body\n  var oBodyGetter = this.getOrigGetter(DocumentProto, 'body');\n  var oBodySetter = this.getOrigSetter(DocumentProto, 'body');\n  if (oBodyGetter && oBodySetter) {\n    this.defProp(\n      DocumentProto,\n      'body',\n      function body(newBody) {\n        if (\n          newBody &&\n          (newBody instanceof HTMLBodyElement ||\n            newBody instanceof HTMLFrameSetElement)\n        ) {\n          wombat.rewriteElemComplete(newBody);\n        }\n        return oBodySetter.call(wombat.proxyToObj(this), newBody);\n      },\n      oBodyGetter\n    );\n  }\n};\n\n/**\n * Inits wombat in the supplied iframe\n * @param {HTMLIFrameElement} iframe\n */\nWombat.prototype.initIframeWombat = function(iframe) {\n  var win;\n\n  if (iframe._get_contentWindow) {\n    win = iframe._get_contentWindow.call(iframe); // eslint-disable-line no-useless-call\n  } else {\n    win = iframe.contentWindow;\n  }\n\n  try {\n    if (!win || win === this.$wbwindow || win._skip_wombat || win._wb_wombat) {\n      return;\n    }\n  } catch (e) {\n    return;\n  }\n\n  var src = iframe.src;\n  //var src = this.wb_getAttribute.call(iframe, 'src');\n\n  this.initNewWindowWombat(win, src);\n};\n\n/**\n * Initializes wombat in the supplied window IFF the src URL of the window is\n * not the empty string, about:blank, or a \"javascript:\" URL\n * @param {Window} win\n * @param {string} [src] unrewritten url\n */\nWombat.prototype.initNewWindowWombat = function(win, src) {\n  var fullWombat = false;\n\n  if (!win || win._wb_wombat) return;\n\n  if (\n    !src ||\n    src === '' ||\n    this.startsWithOneOf(src, ['about:blank', 'javascript:'])\n  ) {\n    fullWombat = true;\n  }\n\n\n  if (!fullWombat && this.wb_info.isSW) {\n    var origURL = this.extractOriginalURL(src);\n    if (origURL === 'about:blank' || origURL.startsWith('srcdoc:') || origURL.startsWith('blob:')) {\n      fullWombat = true;\n    }\n  }\n\n  if (fullWombat) {\n    // win._WBWombat = wombat_internal(win);\n    // win._wb_wombat = new win._WBWombat(wb_info);\n    var newInfo = {};\n    Object.assign(newInfo, this.wb_info);\n    var wombat = new Wombat(win, newInfo);\n    win._wb_wombat = wombat.wombatInit();\n  } else {\n    // These should get overridden when content is loaded, but just in case...\n    // win._WB_wombat_location = win.location;\n    // win.document.WB_wombat_location = win.document.location;\n    // win._WB_wombat_top = $wbwindow.WB_wombat_top;\n\n    this.initProtoPmOrigin(win);\n    this.initPostMessageOverride(win);\n    this.initMessageEventOverride(win);\n    this.initCheckThisFunc(win);\n    this.initImportWrapperFunc(win);\n  }\n};\n\n/**\n * Applies an override to either window.[setTimeout, setInterval] functions\n * in order to ensure that usage such as [setTimeout|setInterval]('document.location.href = \"xyz.com\"', time)\n * behaves as expected during replay.\n *\n * In this case the supplied string is eval'd in the current context skipping\n * the surrounding scope\n */\nWombat.prototype.initTimeoutIntervalOverrides = function() {\n  var rewriteFn = this.rewriteSetTimeoutInterval;\n  if (this.$wbwindow.setTimeout && !this.$wbwindow.setTimeout.__$wbpatched$__) {\n    var originalSetTimeout = this.$wbwindow.setTimeout;\n    this.$wbwindow.setTimeout = function setTimeout() {\n      return rewriteFn(this, originalSetTimeout, arguments);\n    };\n    this.$wbwindow.setTimeout.__$wbpatched$__ = true;\n  }\n\n  if (\n    this.$wbwindow.setInterval &&\n    !this.$wbwindow.setInterval.__$wbpatched$__\n  ) {\n    var originalSetInterval = this.$wbwindow.setInterval;\n    this.$wbwindow.setInterval = function setInterval() {\n      return rewriteFn(this, originalSetInterval, arguments);\n    };\n    this.$wbwindow.setInterval.__$wbpatched$__ = true;\n  }\n};\n\n/**\n * Applies an overrides to the constructor of window.[Worker, SharedWorker] in\n * order to ensure that the URL argument is rewritten.\n *\n * Applies an override to ServiceWorkerContainer.register in order to ensure\n * that the URLs used in ServiceWorker registration are rewritten.\n *\n * Applies an override to Worklet.addModule in order to ensure that URL\n * to the worklet module is rewritten\n * @see https://html.spec.whatwg.org/multipage/workers.html\n * @see https://w3c.github.io/ServiceWorker/\n * @see https://drafts.css-houdini.org/worklets/#worklet\n */\nWombat.prototype.initWorkerOverrides = function() {\n  var wombat = this;\n\n  if (this.$wbwindow.Worker && !this.$wbwindow.Worker._wb_worker_overridden) {\n    // Worker unrewrite postMessage\n    var orig_worker = this.$wbwindow.Worker;\n    this.$wbwindow.Worker = (function(Worker_) {\n      return function Worker(url, options) {\n        wombat.domConstructorErrorChecker(this, 'Worker', arguments);\n        return new Worker_(wombat.rewriteWorker(url), options);\n      };\n    })(orig_worker);\n\n    this.$wbwindow.Worker.prototype = orig_worker.prototype;\n    Object.defineProperty(this.$wbwindow.Worker.prototype, 'constructor', {\n      value: this.$wbwindow.Worker\n    });\n    this.$wbwindow.Worker._wb_worker_overridden = true;\n  }\n\n  if (\n    this.$wbwindow.SharedWorker &&\n    !this.$wbwindow.SharedWorker.__wb_sharedWorker_overridden\n  ) {\n    // per https://html.spec.whatwg.org/multipage/workers.html#sharedworker\n    var oSharedWorker = this.$wbwindow.SharedWorker;\n    this.$wbwindow.SharedWorker = (function(SharedWorker_) {\n      return function SharedWorker(url, options) {\n        wombat.domConstructorErrorChecker(this, 'SharedWorker', arguments);\n        return new SharedWorker_(wombat.rewriteWorker(url), options);\n      };\n    })(oSharedWorker);\n\n    this.$wbwindow.SharedWorker.prototype = oSharedWorker.prototype;\n    Object.defineProperty(\n      this.$wbwindow.SharedWorker.prototype,\n      'constructor',\n      {\n        value: this.$wbwindow.SharedWorker\n      }\n    );\n    this.$wbwindow.SharedWorker.__wb_sharedWorker_overridden = true;\n  }\n\n  if (\n    this.$wbwindow.ServiceWorkerContainer &&\n    this.$wbwindow.ServiceWorkerContainer.prototype &&\n    this.$wbwindow.ServiceWorkerContainer.prototype.register\n  ) {\n    // https://w3c.github.io/ServiceWorker/\n    var orig_register = this.$wbwindow.ServiceWorkerContainer.prototype\n      .register;\n    this.$wbwindow.ServiceWorkerContainer.prototype.register = function register(\n      scriptURL,\n      options\n    ) {\n      var newScriptURL = new URL(scriptURL, wombat.$wbwindow.document.baseURI)\n        .href;\n      var mod = wombat.getPageUnderModifier();\n      if (options && options.scope) {\n        options.scope = wombat.rewriteUrl(options.scope, false, mod);\n      } else {\n        options = { scope: wombat.rewriteUrl('/', false, mod) };\n      }\n      return orig_register.call(\n        this,\n        wombat.rewriteUrl(newScriptURL, false, 'sw_'),\n        options\n      );\n    };\n  }\n\n  if (\n    this.$wbwindow.Worklet &&\n    this.$wbwindow.Worklet.prototype &&\n    this.$wbwindow.Worklet.prototype.addModule &&\n    !this.$wbwindow.Worklet.__wb_workerlet_overridden\n  ) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Worklet/addModule\n    var oAddModule = this.$wbwindow.Worklet.prototype.addModule;\n    this.$wbwindow.Worklet.prototype.addModule = function addModule(\n      moduleURL,\n      options\n    ) {\n      var rwModuleURL = wombat.rewriteUrl(moduleURL, false, 'js_');\n      return oAddModule.call(this, rwModuleURL, options);\n    };\n    this.$wbwindow.Worklet.__wb_workerlet_overridden = true;\n  }\n};\n\n/**\n * Applies overrides to the getter setter functions of the supplied object\n * for the properties defined in {@link Wombat#URL_PROPS} IFF\n * Object.defineProperty is defined\n * @param {Object} loc\n * @param {function} oSetter\n * @param {function} oGetter\n */\nWombat.prototype.initLocOverride = function(loc, oSetter, oGetter) {\n  if (Object.defineProperty) {\n    for (var i = 0; i < this.URL_PROPS.length; i++) {\n      var prop = this.URL_PROPS[i];\n      this.defProp(\n        loc,\n        prop,\n        this.makeSetLocProp(prop, oSetter, oGetter),\n        this.makeGetLocProp(prop, oGetter),\n        true\n      );\n    }\n  }\n};\n\n/**\n * Initialized WombatLocation on the supplied window object and adds the\n * __WB_pmw function on the window, as well as, defines WB_wombat_location\n * as property on the prototype of Object and adds the _WB_wombat_location\n * and __WB_check_loc properties to the supplied window\n * @param {Window} win\n */\nWombat.prototype.initWombatLoc = function(win) {\n  if (!win || (win.WB_wombat_location && win.document.WB_wombat_location)) {\n    return;\n  }\n\n  // Location\n  var wombat_location = new _wombatLocation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](win.location, this);\n\n  var wombat = this;\n\n  if (Object.defineProperty) {\n    var setter = function(value) {\n      var loc =\n        this._WB_wombat_location ||\n        (this.defaultView && this.defaultView._WB_wombat_location);\n\n      if (loc) {\n        loc.href = value;\n      }\n      win.location = wombat.rewriteUrl(value);\n    };\n\n    var getter = function() {\n      return (\n        this._WB_wombat_location ||\n        (this.defaultView && this.defaultView._WB_wombat_location) ||\n        this.location\n      );\n    };\n\n    this.defProp(win.Object.prototype, 'WB_wombat_location', setter, getter);\n\n    this.initProtoPmOrigin(win);\n\n    win._WB_wombat_location = wombat_location;\n  } else {\n    win.WB_wombat_location = wombat_location;\n\n    // Check quickly after page load\n    setTimeout(this.checkAllLocations, 500);\n\n    // Check periodically every few seconds\n    setInterval(this.checkAllLocations, 500);\n  }\n};\n\n/**\n * Adds the __WB_pmw property to prototype of Object and adds the\n * __WB_check_loc property to window\n * @param {Window} win\n */\nWombat.prototype.initProtoPmOrigin = function(win) {\n  if (win.Object.prototype.__WB_pmw) return;\n\n  var pm_origin = function pm_origin(origin_window) {\n    this.__WB_source = origin_window;\n    return this;\n  };\n\n  try {\n    win.Object.defineProperty(win.Object.prototype, '__WB_pmw', {\n      get: function() {\n        return pm_origin;\n      },\n      set: function() {},\n      configurable: true,\n      enumerable: false\n    });\n  } catch (e) {}\n\n  win.__WB_check_loc = function(loc, args) {\n    if (loc instanceof Location || loc instanceof _wombatLocation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n      // args, if provided, should be the 'arguments' from calling function\n      // check if the location is actually a locally passed in argument,\n      // if so, don't assign to global location\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          if (loc === args[i]) {\n            return {};\n          }\n        }\n      }\n      return this.WB_wombat_location;\n    } else {\n      return {};\n    }\n  };\n};\n\n/**\n * Add proxy object globals, assign func and 'this' wrapper, to global Object.prototype\n *\n */\n\nWombat.prototype.initCheckThisFunc = function(win) {\n  try {\n    if (!win.Object.prototype[this.WB_CHECK_THIS_FUNC]) {\n      win.Object.defineProperty(win.Object.prototype, this.WB_CHECK_THIS_FUNC, {\n        configutable: false,\n        enumerable: false,\n        value: function(thisObj) {\n          return (thisObj && thisObj._WB_wombat_obj_proxy ? thisObj._WB_wombat_obj_proxy : thisObj);\n        },\n      });\n    }\n  } catch(e) {}\n};\n\n\nWombat.prototype.initImportWrapperFunc = function(win) {\n  var wombat = this;\n  win.____wb_rewrite_import__ = function(base, url) {\n    // if base provided (set to import.meta.url), use that as base for imports\n    if (base) {\n      url = new URL(url, base).href;\n    }\n    return import(/*webpackIgnore: true*/ wombat.rewriteUrl(url, false, 'esm_'));\n  };\n};\n\n/**\n * Override Object.getOwnPropertyNames() to filter out special wombat-added properties\n *\n */\n\nWombat.prototype.overrideGetOwnPropertyNames = function(win) {\n  var orig_getOwnPropertyNames = win.Object.getOwnPropertyNames;\n\n  var removeProps = [\n    this.WB_CHECK_THIS_FUNC,\n    'WB_wombat_location',\n    '__WB_pmw',\n    'WB_wombat_top',\n    'WB_wombat_eval',\n    'WB_wombat_runEval'\n  ];\n\n  try {\n    win.Object.defineProperty(win.Object, 'getOwnPropertyNames', {\n      value: function(object) {\n        var props = orig_getOwnPropertyNames(object);\n\n        for (var i = 0; i < removeProps.length; i++) {\n          var foundInx = props.indexOf(removeProps[i]);\n          if (foundInx >= 0) {\n            props.splice(foundInx, 1);\n          }\n        }\n\n        return props;\n      }\n    });\n  } catch (e) {\n    console.log(e);\n  }\n};\n\n/**\n * Adds listeners for `message` and `hashchange` to window of the browser context wombat is in\n * in order to ensure that actual top (archive top frame containing the replay iframe)\n * browser history is updated IFF the history manipulation happens in the replay top\n */\nWombat.prototype.initHashChange = function() {\n  if (!this.$wbwindow.__WB_top_frame) return;\n\n  var wombat = this;\n\n  var receive_hash_change = function receive_hash_change(event) {\n    if (!event.data || !event.data.from_top) {\n      return;\n    }\n\n    var message = event.data.message;\n\n    if (!message.wb_type) return;\n\n    if (message.wb_type === 'outer_hashchange') {\n      if (wombat.$wbwindow.location.hash != message.hash) {\n        wombat.$wbwindow.location.hash = message.hash;\n      }\n    }\n  };\n\n  var send_hash_change = function send_hash_change() {\n    var message = {\n      wb_type: 'hashchange',\n      hash: wombat.$wbwindow.location.hash\n    };\n\n    wombat.sendTopMessage(message);\n  };\n\n  this.$wbwindow.addEventListener('message', receive_hash_change);\n\n  this.$wbwindow.addEventListener('hashchange', send_hash_change);\n};\n\n/**\n * Overrides window.postMessage in order to ensure that messages sent\n * via this function are routed to the correct window, especially that\n * messages sent to the \"top frame\" do not go to archive top but replay top.\n *\n * This function also applies an override to EventTarget.[addEventListener, removeEventListener]\n * to ensure that listening to events behaves correctly during replay.\n *\n * This function is the place where the `onmessage` and `onstorage` setter functions\n * are overridden.\n * @param {Window} $wbwindow\n */\nWombat.prototype.initPostMessageOverride = function($wbwindow) {\n  if (!$wbwindow.postMessage || $wbwindow.__orig_postMessage) {\n    return;\n  }\n\n  var orig = $wbwindow.postMessage;\n  var wombat = this;\n\n  $wbwindow.__orig_postMessage = orig;\n\n  // use this_obj.__WB_source not window to fix google calendar embeds, pm_origin sets this.__WB_source\n  var postmessage_rewritten = function postMessage(\n    message,\n    targetOrigin,\n    transfer,\n    from_top\n  ) {\n    var from;\n    var src_id;\n    var this_obj = wombat.proxyToObj(this);\n    if (!this_obj) {\n      this_obj = $wbwindow;\n      this_obj.__WB_source = $wbwindow;\n    }\n    if (this_obj.__WB_source && this_obj.__WB_source.WB_wombat_location) {\n      var source = this_obj.__WB_source;\n\n      from = source.WB_wombat_location.origin;\n      if (!this_obj.__WB_win_id) {\n        this_obj.__WB_win_id = {};\n        this_obj.__WB_counter = 0;\n      }\n\n      if (!source.__WB_id) {\n        var id = this_obj.__WB_counter;\n        source.__WB_id = id + source.WB_wombat_location.href;\n        this_obj.__WB_counter += 1;\n      }\n      this_obj.__WB_win_id[source.__WB_id] = source;\n\n      src_id = source.__WB_id;\n\n      this_obj.__WB_source = undefined;\n    } else {\n      from = window.WB_wombat_location.origin;\n    }\n\n    var to_origin = targetOrigin;\n\n    // if passed in origin is the replay (rewriting missed somewhere?)\n    // set origin to current 'from' origin\n    if (to_origin === this_obj.location.origin) {\n      to_origin = from;\n    }\n\n    var new_message = {\n      from: from,\n      to_origin: to_origin,\n      src_id: src_id,\n      message: message,\n      from_top: from_top\n    };\n\n    // set to 'real' origin if not '*'\n    if (targetOrigin !== '*') {\n      // if target origin is null (about:blank) or empty, don't pass event at all\n      // as it would never succeed\n      if (\n        this_obj.location.origin === 'null' ||\n        this_obj.location.origin === ''\n      ) {\n        return;\n      }\n      // set to actual (rewritten) origin\n      targetOrigin = this_obj.location.origin;\n    }\n\n    // console.log(`Sending ${from} -> ${to_origin} (${targetOrigin}) ${message}`);\n\n    return orig.call(this_obj, new_message, targetOrigin, transfer);\n  };\n\n  $wbwindow.postMessage = postmessage_rewritten;\n  $wbwindow.Window.prototype.postMessage = postmessage_rewritten;\n\n  var eventTarget = null;\n  if ($wbwindow.EventTarget && $wbwindow.EventTarget.prototype) {\n    eventTarget = $wbwindow.EventTarget.prototype;\n  } else {\n    eventTarget = $wbwindow;\n  }\n\n  // ADD\n  var _oAddEventListener = eventTarget.addEventListener;\n  eventTarget.addEventListener = function addEventListener(\n    type,\n    listener,\n    useCapture\n  ) {\n    var obj = wombat.proxyToObj(this);\n    var rwListener;\n    if (type === 'message') {\n      rwListener = wombat.message_listeners.add_or_get(listener, function() {\n        return (0,_listeners_js__WEBPACK_IMPORTED_MODULE_4__.wrapEventListener)(listener, obj, wombat);\n      });\n    } else if (type === 'storage') {\n      wombat.storage_listeners.add_or_get(listener, function() {\n        return (0,_listeners_js__WEBPACK_IMPORTED_MODULE_4__.wrapSameOriginEventListener)(listener, obj);\n      });\n    } else {\n      rwListener = listener;\n    }\n    if (rwListener) {\n      return _oAddEventListener.call(obj, type, rwListener, useCapture);\n    }\n  };\n\n  // REMOVE\n  var _oRemoveEventListener = eventTarget.removeEventListener;\n  eventTarget.removeEventListener = function removeEventListener(\n    type,\n    listener,\n    useCapture\n  ) {\n    var obj = wombat.proxyToObj(this);\n    var rwListener;\n\n    if (type === 'message') {\n      rwListener = wombat.message_listeners.remove(listener);\n    } else if (type === 'storage') {\n      wombat.storage_listeners.remove(listener);\n    } else {\n      rwListener = listener;\n    }\n\n    if (rwListener) {\n      return _oRemoveEventListener.call(obj, type, rwListener, useCapture);\n    }\n  };\n\n  // ONMESSAGE & ONSTORAGE\n  var override_on_prop = function(onevent, wrapperFN) {\n    // var orig_getter = _wombat.getOrigGetter($wbwindow, onevent)\n    var orig_setter = wombat.getOrigSetter($wbwindow, onevent);\n\n    var setter = function(value) {\n      this['__orig_' + onevent] = value;\n      var obj = wombat.proxyToObj(this);\n      var listener = value ? wrapperFN(value, obj, wombat) : value;\n      return orig_setter.call(obj, listener);\n    };\n\n    var getter = function() {\n      return this['__orig_' + onevent];\n    };\n\n    wombat.defProp($wbwindow, onevent, setter, getter);\n  };\n  override_on_prop('onmessage', _listeners_js__WEBPACK_IMPORTED_MODULE_4__.wrapEventListener);\n  override_on_prop('onstorage', _listeners_js__WEBPACK_IMPORTED_MODULE_4__.wrapSameOriginEventListener);\n};\n\n/**\n * Applies overrides to the MessageEvent.[target, srcElement, currentTarget, eventPhase, path, source]\n * in order to ensure they are not a JS Proxy used by wombat\n * @param {Window} $wbwindow\n */\nWombat.prototype.initMessageEventOverride = function($wbwindow) {\n  if (!$wbwindow.MessageEvent || $wbwindow.MessageEvent.prototype.__extended) {\n    return;\n  }\n  this.addEventOverride('target');\n  this.addEventOverride('srcElement');\n  this.addEventOverride('currentTarget');\n  this.addEventOverride('eventPhase');\n  this.addEventOverride('path');\n  this.overridePropToProxy($wbwindow.MessageEvent.prototype, 'source');\n  $wbwindow.MessageEvent.prototype.__extended = true;\n};\n\n/**\n * Applies overrides to the constructors\n *  - UIEvent\n *  - MouseEvent\n *  - TouchEvent\n *  - KeyboardEvent\n *  - WheelEvent\n *  - InputEvent\n *  - CompositionEvent\n *\n * in order to ensure the proper behavior of the events when wombat is using\n * an JS Proxy\n */\nWombat.prototype.initUIEventsOverrides = function() {\n  this.overrideAnUIEvent('UIEvent');\n  this.overrideAnUIEvent('MouseEvent');\n  this.overrideAnUIEvent('TouchEvent');\n  this.overrideAnUIEvent('FocusEvent');\n  this.overrideAnUIEvent('KeyboardEvent');\n  this.overrideAnUIEvent('WheelEvent');\n  this.overrideAnUIEvent('InputEvent');\n  this.overrideAnUIEvent('CompositionEvent');\n};\n\n/**\n * Applies an override to window.open in order to ensure the URL argument is rewritten.\n * Also applies the same override to the open function of all frames returned by\n * window.frames\n */\nWombat.prototype.initOpenOverride = function() {\n  var orig = this.$wbwindow.open;\n\n  if (this.$wbwindow.Window.prototype.open) {\n    orig = this.$wbwindow.Window.prototype.open;\n  }\n\n  var wombat = this;\n\n  var open_rewritten = function open(strUrl, strWindowName, strWindowFeatures) {\n    if (strWindowName) {\n      strWindowName = wombat.rewriteAttrTarget(strWindowName);\n    }\n    var rwStrUrl = wombat.rewriteUrl(strUrl, false);\n    var res = orig.call(\n      wombat.proxyToObj(this),\n      rwStrUrl,\n      strWindowName,\n      strWindowFeatures\n    );\n    wombat.initNewWindowWombat(res, strUrl);\n    return res;\n  };\n\n  this.$wbwindow.open = open_rewritten;\n\n  if (this.$wbwindow.Window.prototype.open) {\n    this.$wbwindow.Window.prototype.open = open_rewritten;\n  }\n\n  for (var i = 0; i < this.$wbwindow.frames.length; i++) {\n    try {\n      this.$wbwindow.frames[i].open = open_rewritten;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n};\n\n/**\n * Rewrite 'target' for anchor tag or window.open\n */\n\nWombat.prototype.rewriteAttrTarget = function(target) {\n  if (!this.wb_info.target_frame) {\n    return target;\n  }\n\n  if (target === '_blank' || target === '_parent' || target === '_top') {\n    return this.wb_info.target_frame;\n  }\n\n  // if target is a different name, and we are the top frame, assume intent\n  // is to open a new window, and not some iframe\n  // (a further check could also be to check list of iframes to see if the target matches)\n  if (target && this.$wbwindow === this.$wbwindow.__WB_replay_top) {\n    return this.wb_info.target_frame;\n  }\n\n  return target;\n};\n\n/**\n * Applies an override to the getter and setter functions of document.cookie\n * in order to ensure that cookies are rewritten\n */\nWombat.prototype.initCookiesOverride = function() {\n  var orig_get_cookie = this.getOrigGetter(this.$wbwindow.document, 'cookie');\n  var orig_set_cookie = this.getOrigSetter(this.$wbwindow.document, 'cookie');\n\n  if (!orig_get_cookie) {\n    orig_get_cookie = this.getOrigGetter(\n      this.$wbwindow.Document.prototype,\n      'cookie'\n    );\n  }\n  if (!orig_set_cookie) {\n    orig_set_cookie = this.getOrigSetter(\n      this.$wbwindow.Document.prototype,\n      'cookie'\n    );\n  }\n\n  var rwCookieReplacer = function(m, d1) {\n    var date = new Date(d1);\n    if (isNaN(date.getTime())) {\n      return 'Expires=Thu,| 01 Jan 1970 00:00:00 GMT';\n    }\n    var finalDate = new Date(date.getTime() + Date.__WB_timediff);\n    return 'Expires=' + finalDate.toUTCString().replace(',', ',|');\n  };\n\n  var wombat = this;\n  var set_cookie = function cookie(value) {\n    if (!value) return;\n    var newValue = value.replace(wombat.cookie_expires_regex, rwCookieReplacer);\n    var cookies = newValue.split(wombat.SetCookieRe);\n    for (var i = 0; i < cookies.length; i++) {\n      cookies[i] = wombat.rewriteCookie(cookies[i]);\n    }\n    return orig_set_cookie.call(wombat.proxyToObj(this), cookies.join(','));\n  };\n\n  var get_cookie = function cookie() {\n    return orig_get_cookie.call(wombat.proxyToObj(this));\n  };\n\n  this.defProp(this.$wbwindow.document, 'cookie', set_cookie, get_cookie);\n};\n\n/**\n * Applies an override to navigator.[registerProtocolHandler, unregisterProtocolHandler] in order to\n * ensure that the URI argument is rewritten\n */\nWombat.prototype.initRegisterUnRegPHOverride = function() {\n  var wombat = this;\n  var winNavigator = this.$wbwindow.navigator;\n  if (winNavigator.registerProtocolHandler) {\n    var orig_registerPH = winNavigator.registerProtocolHandler;\n    winNavigator.registerProtocolHandler = function registerProtocolHandler(\n      protocol,\n      uri,\n      title\n    ) {\n      return orig_registerPH.call(\n        this,\n        protocol,\n        wombat.rewriteUrl(uri),\n        title\n      );\n    };\n  }\n\n  if (winNavigator.unregisterProtocolHandler) {\n    var origUnregPH = winNavigator.unregisterProtocolHandler;\n    winNavigator.unregisterProtocolHandler = function unregisterProtocolHandler(\n      scheme,\n      url\n    ) {\n      return origUnregPH.call(this, scheme, wombat.rewriteUrl(url));\n    };\n  }\n};\n\n/**\n * Applies an override to navigator.sendBeacon in order to ensure that\n * the URL argument is rewritten. This ensures that when a page is rewritten\n * no information about who is viewing is leaked to the outside world\n */\nWombat.prototype.initBeaconOverride = function() {\n  if (!this.$wbwindow.navigator.sendBeacon) return;\n  var orig_sendBeacon = this.$wbwindow.navigator.sendBeacon;\n  var wombat = this;\n  this.$wbwindow.navigator.sendBeacon = function sendBeacon(url, data) {\n    try {\n      return orig_sendBeacon.call(this, wombat.rewriteUrl(url), data);\n    } catch(e) {\n      return true;\n    }\n  };\n};\n\nWombat.prototype.initMiscNavigatorOverrides = function() {\n  if (this.$wbwindow.navigator.mediaDevices) {\n    this.$wbwindow.navigator.mediaDevices.setCaptureHandleConfig = function() {};\n  }\n};\n\n\n/**\n * Applies an override to the constructor of the PresentationRequest interface object\n * in order to rewrite its URL(s) arguments\n * @see https://w3c.github.io/presentation-api/#constructing-a-presentationrequest\n */\nWombat.prototype.initPresentationRequestOverride = function() {\n  if (\n    this.$wbwindow.PresentationRequest &&\n    this.$wbwindow.PresentationRequest.prototype\n  ) {\n    var wombat = this;\n    var origPresentationRequest = this.$wbwindow.PresentationRequest;\n    this.$wbwindow.PresentationRequest = (function(PresentationRequest_) {\n      return function PresentationRequest(url) {\n        wombat.domConstructorErrorChecker(\n          this,\n          'PresentationRequest',\n          arguments\n        );\n        var rwURL = url;\n        if (url != null) {\n          if (Array.isArray(rwURL)) {\n            for (var i = 0; i < rwURL.length; i++) {\n              rwURL[i] = wombat.rewriteUrl(rwURL[i], true, 'mp_');\n            }\n          } else {\n            rwURL = wombat.rewriteUrl(url, true, 'mp_');\n          }\n        }\n        return new PresentationRequest_(rwURL);\n      };\n    })(this.$wbwindow.PresentationRequest);\n    this.$wbwindow.PresentationRequest.prototype =\n      origPresentationRequest.prototype;\n    Object.defineProperty(\n      this.$wbwindow.PresentationRequest.prototype,\n      'constructor',\n      {\n        value: this.$wbwindow.PresentationRequest\n      }\n    );\n  }\n};\n\n/**\n * Applies an override that disables the pages ability to send OS native\n * notifications. Also disables the ability of the replayed page to retrieve the geolocation\n * of the view.\n *\n * This is done in order to ensure that no malicious abuse of these functions\n * can happen during replay.\n */\nWombat.prototype.initDisableNotificationsGeoLocation = function() {\n  if (window.Notification) {\n    window.Notification.requestPermission = function requestPermission(\n      callback\n    ) {\n      if (callback) {\n        callback('denied');\n      }\n\n      return Promise.resolve('denied');\n    };\n  }\n\n  var applyOverride = function(on) {\n    if (!on) return;\n    if (on.getCurrentPosition) {\n      on.getCurrentPosition = function getCurrentPosition(\n        success,\n        error,\n        options\n      ) {\n        if (error) {\n          error({ code: 2, message: 'not available' });\n        }\n      };\n    }\n    if (on.watchPosition) {\n      on.watchPosition = function watchPosition(success, error, options) {\n        if (error) {\n          error({ code: 2, message: 'not available' });\n        }\n      };\n    }\n  };\n  if (window.geolocation) {\n    applyOverride(window.geolocation);\n  }\n  if (window.navigator.geolocation) {\n    applyOverride(window.navigator.geolocation);\n  }\n};\n\n/**\n * Applies an override to window.[localStorage, sessionStorage] storage in order to ensure\n * that the replayed page can use both interfaces as expected during replay.\n */\nWombat.prototype.initStorageOverride = function() {\n  this.addEventOverride('storageArea', this.$wbwindow.StorageEvent.prototype);\n\n  _wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.ThrowExceptions.yes = false;\n\n  var initStorage = {};\n\n  if (this.wb_info.storage) {\n    try {\n      initStorage = JSON.parse(atob(this.wb_info.storage));\n    } catch (e) {\n      console.warn('Error parsing storage, storages not loaded');\n    }\n  }\n\n  (0,_customStorage_js__WEBPACK_IMPORTED_MODULE_1__.createStorage)(this, 'localStorage', initStorage.local);\n  (0,_customStorage_js__WEBPACK_IMPORTED_MODULE_1__.createStorage)(this, 'sessionStorage', initStorage.session);\n\n  // ensure localStorage instanceof Storage works\n  this.$wbwindow.Storage = _customStorage_js__WEBPACK_IMPORTED_MODULE_1__.Storage;\n  _wombatUtils_js__WEBPACK_IMPORTED_MODULE_5__.ThrowExceptions.yes = true;\n};\n\n\nWombat.prototype.initIndexedDBOverride = function() {\n  if (!this.$wbwindow.IDBFactory) {\n    return;\n  }\n\n  var proto = this.$wbwindow.IDBFactory.prototype;\n\n  var prefix = 'wb-' + this.wb_orig_origin + '-';\n\n  var orig_open = proto.open;\n  proto.open = function(dbName, version) {\n    return orig_open.call(this, prefix + dbName, version);\n  };\n\n  var orig_delete = proto.deleteDatabase;\n  proto.delete = function(dbName) {\n    return orig_delete.call(this, prefix + dbName, options);\n  };\n\n  var orig_databases = proto.databases;\n  proto.databases = function() {\n    var func = this;\n    return new Promise(function (resolve, reject) {\n      orig_databases.call(func).then(function(dbList) {\n        var keys = [];\n        for (var i = 0; i < dbList.length; i++) {\n          if (dbList[i].name.indexOf(prefix) === 0) {\n            keys.push({name: dbList[i].name.substring(prefix.length), version: dbList[i].version});\n          }\n        }\n        resolve(keys);\n      }).catch(function(err) { reject(err); });\n    });\n  };\n};\n\nWombat.prototype.initCachesOverride = function() {\n  if (!this.$wbwindow.CacheStorage) {\n    return;\n  }\n\n  // disable access to extension apis\n  if (this.$wbwindow.chrome) {\n    this.$wbwindow.chrome = {};\n  }\n\n  var proto = this.$wbwindow.CacheStorage.prototype;\n\n  var prefix = 'wb-' + this.wb_orig_origin + '-';\n\n  var orig_open = proto.open;\n  proto.open = function(cacheName) {\n    return orig_open.call(this, prefix + cacheName);\n  };\n\n  var orig_has = proto.has;\n  proto.has = function(cacheName) {\n    return orig_has.call(this, prefix + cacheName);\n  };\n\n  var orig_delete = proto.delete;\n  proto.delete = function(cacheName) {\n    return orig_delete.call(this, prefix + cacheName);\n  };\n\n  var orig_keys = proto.keys;\n  proto.keys = function() {\n    var func = this;\n    return new Promise(function (resolve, reject) {\n      orig_keys.call(func).then(function(keyList) {\n        var keys = [];\n        for (var i = 0; i < keyList.length; i++) {\n          if (keyList[i].indexOf(prefix) === 0) {\n            keys.push(keyList[i].substring(prefix.length));\n          }\n        }\n        resolve(keys);\n      }).catch(function(err) { reject(err); });\n    });\n  };\n\n  var orig_match = proto.match;\n  proto.match = function match(request, opts) {\n    var caches = this;\n\n    return this.keys().then(function(cacheNames) {\n      var match;\n\n      return cacheNames.reduce(function(chain, cacheName) {\n        return chain.then(function() {\n          return match || caches.open(cacheName).then(function(cache) {\n            return cache.match(request, opts);\n          }).then(function(response) {\n            match = response;\n            return match;\n          });\n        });\n      }, Promise.resolve());\n    });\n  };\n};\n\n/**\n * Initializes the wombat window JS Proxy object IFF JS Proxies are available.\n * @param {Window} $wbwindow\n * @return {Proxy<Window>}\n */\nWombat.prototype.initWindowObjProxy = function($wbwindow) {\n  if (!$wbwindow.Proxy) return undefined;\n\n  var ownProps = this.getAllOwnProps($wbwindow);\n  var funCache = {};\n  var wombat = this;\n  var windowProxy = new $wbwindow.Proxy(\n    {},\n    {\n      get: function(target, prop) {\n        switch (prop) {\n          case 'top':\n            return wombat.$wbwindow.WB_wombat_top._WB_wombat_obj_proxy;\n          case 'parent':\n            // if at replay top, return the top object proxy\n            if (wombat.$wbwindow === wombat.$wbwindow.WB_wombat_top) {\n              return wombat.$wbwindow.WB_wombat_top._WB_wombat_obj_proxy;\n            }\n            // attempt to get the object proxy from parent, may throw if cross-origin\n            try {\n              var parentProxy = wombat.$wbwindow.parent._WB_wombat_obj_proxy;\n              if (parentProxy) return parentProxy;\n            } catch (e) {}\n\n            // default to replay-top object proxy if all else fails\n            return wombat.$wbwindow.WB_wombat_top._WB_wombat_obj_proxy;\n\n        }\n        return wombat.defaultProxyGet($wbwindow, prop, ownProps, funCache);\n      },\n      set: function(target, prop, value) {\n        switch (prop) {\n          case 'location':\n            $wbwindow.WB_wombat_location = value;\n            return true;\n          case 'postMessage':\n          case 'document':\n            return true;\n        }\n        try {\n          if (!Reflect.set(target, prop, value)) {\n            return false;\n          }\n        } catch (e) {}\n        return Reflect.set($wbwindow, prop, value);\n      },\n      has: function(target, prop) {\n        return prop in $wbwindow;\n      },\n      ownKeys: function(target) {\n        return Object.getOwnPropertyNames($wbwindow).concat(\n          Object.getOwnPropertySymbols($wbwindow)\n        );\n      },\n      getOwnPropertyDescriptor: function(target, key) {\n        // first try the underlying object's descriptor\n        // (to match defineProperty() behavior)\n        var descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (!descriptor) {\n          descriptor = Object.getOwnPropertyDescriptor($wbwindow, key);\n          // if using window's descriptor, must ensure it's configurable\n          if (descriptor) {\n            descriptor.configurable = true;\n          }\n        }\n        return descriptor;\n      },\n      getPrototypeOf: function(target) {\n        return Object.getPrototypeOf($wbwindow);\n      },\n      setPrototypeOf: function(target, newProto) {\n        return false;\n      },\n      isExtensible: function(target) {\n        return Object.isExtensible($wbwindow);\n      },\n      preventExtensions: function(target) {\n        Object.preventExtensions($wbwindow);\n        return true;\n      },\n      deleteProperty: function(target, prop) {\n        var propDescriptor = Object.getOwnPropertyDescriptor($wbwindow, prop);\n        if (propDescriptor === undefined) {\n          return true;\n        }\n        if (propDescriptor.configurable === false) {\n          return false;\n        }\n        delete target[prop];\n        delete $wbwindow[prop];\n        return true;\n      },\n      defineProperty: function(target, prop, desc) {\n        var ndesc = desc || {};\n        if (ndesc.value === undefined && ndesc.get === undefined) {\n          ndesc.value = $wbwindow[prop];\n        }\n        Reflect.defineProperty($wbwindow, prop, ndesc);\n        return Reflect.defineProperty(target, prop, ndesc);\n      }\n    }\n  );\n  $wbwindow._WB_wombat_obj_proxy = windowProxy;\n  return windowProxy;\n};\n\n/**\n * Initializes the wombat document JS Proxy object IFF JS Proxies are available.\n * This function also applies the {@link initDocOverrides} overrides regardless\n * if JS Proxies are available.\n * @param {Document} $document\n * @return {Proxy<Document>}\n */\nWombat.prototype.initDocumentObjProxy = function($document) {\n  this.initDocOverrides($document);\n  if (!this.$wbwindow.Proxy) return undefined;\n  var funCache = {};\n  var ownProps = this.getAllOwnProps($document);\n  var wombat = this;\n  var documentProxy = new this.$wbwindow.Proxy($document, {\n    get: function(target, prop) {\n      return wombat.defaultProxyGet($document, prop, ownProps, funCache);\n    },\n    set: function(target, prop, value) {\n      if (prop === 'location') {\n        $document.WB_wombat_location = value;\n      } else {\n        target[prop] = value;\n      }\n      return true;\n    }\n  });\n  $document._WB_wombat_obj_proxy = documentProxy;\n  return documentProxy;\n};\n\n/**\n * Initializes and starts the auto-fetch worker IFF wbUseAFWorker is true\n */\nWombat.prototype.initAutoFetchWorker = function() {\n  if (!this.wbUseAFWorker) return;\n  var af = new _autoFetcher_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, {\n    isTop: this.$wbwindow === this.$wbwindow.__WB_replay_top,\n    workerURL:\n      (this.wb_info.auto_fetch_worker_prefix || this.wb_info.static_prefix) +\n      'autoFetchWorker.js?init=' +\n      encodeURIComponent(\n        JSON.stringify({\n          mod: this.wb_info.mod,\n          prefix: this.wb_abs_prefix,\n          rwRe: this.wb_unrewrite_rx.source\n        })\n      )\n  });\n  this.WBAutoFetchWorker = af;\n  this.$wbwindow.$WBAutoFetchWorker$ = af;\n  var wombat = this;\n  this.utilFns.wbSheetMediaQChecker = function checkStyle() {\n    // used only for link[rel='stylesheet'] so we remove our listener\n    wombat._removeEventListener(\n      this,\n      'load',\n      wombat.utilFns.wbSheetMediaQChecker\n    );\n    // check no op condition\n    if (this.sheet == null) return;\n    // defer extraction to be nice :)\n    if (wombat.WBAutoFetchWorker) {\n      wombat.WBAutoFetchWorker.deferredSheetExtraction(this.sheet);\n    }\n  };\n};\n\n/**\n * Initializes the listener for when the document.readyState is \"complete\" in\n * order to send archive top the information about the title of the page and\n * have it add any favicons of the replayed page to its own markup.\n *\n * The wb_type=\"load\" message is sent to archive top IFF the page it originates\n * is replay top\n * @param {Object} wbinfo\n */\nWombat.prototype.initTopFrameNotify = function(wbinfo) {\n  var wombat = this;\n\n  var notify_top = function notify_top(event) {\n    if (!wombat.$wbwindow.__WB_top_frame) {\n      var hash = wombat.$wbwindow.location.hash;\n      wombat.$wbwindow.location.replace(wbinfo.top_url + hash);\n      return;\n    }\n\n    if (!wombat.$wbwindow.WB_wombat_location) return;\n\n    var url = wombat.$wbwindow.WB_wombat_location.href;\n\n    if (\n      typeof url !== 'string' ||\n      url === 'about:blank' ||\n      url.indexOf('javascript:') === 0\n    ) {\n      return;\n    }\n\n    if (\n      wombat.$wbwindow.document.readyState === 'complete' &&\n      wombat.wbUseAFWorker &&\n      wombat.WBAutoFetchWorker\n    ) {\n      wombat.WBAutoFetchWorker.extractFromLocalDoc();\n    }\n\n    if (wombat.$wbwindow !== wombat.$wbwindow.__WB_replay_top) {\n      return;\n    }\n\n    var icons = [];\n    var hicons = wombat.$wbwindow.document.querySelectorAll(\n      'link[rel*=\\'icon\\']'\n    );\n\n    for (var i = 0; i < hicons.length; i++) {\n      var hicon = hicons[i];\n      icons.push({\n        rel: hicon.rel,\n        href: wombat.wb_getAttribute.call(hicon, 'href')\n      });\n    }\n\n    icons.push({\n      rel: 'icon',\n      href: wombat.rewriteUrl('/favicon.ico'),\n    });\n\n    var message = {\n      icons: icons,\n      url: wombat.$wbwindow.WB_wombat_location.href,\n      ts: wombat.wb_info.timestamp,\n      request_ts: wombat.wb_info.request_ts,\n      is_live: wombat.wb_info.is_live,\n      title: wombat.$wbwindow.document ? wombat.$wbwindow.document.title : '',\n      readyState: wombat.$wbwindow.document.readyState,\n      wb_type: 'load'\n    };\n\n    wombat.sendTopMessage(message);\n  };\n\n  if (this.$wbwindow.document.readyState === 'complete') {\n    notify_top();\n  } else if (this.$wbwindow.addEventListener) {\n    this.$wbwindow.document.addEventListener('readystatechange', notify_top);\n  } else if (this.$wbwindow.attachEvent) {\n    this.$wbwindow.document.attachEvent('onreadystatechange', notify_top);\n  }\n};\n\n/**\n * Initialises the _WB_replay_top and _WB_top_frame properties on window\n * @param {Window} $wbwindow\n */\nWombat.prototype.initTopFrame = function($wbwindow) {\n  // proxy mode\n  if (this.wb_is_proxy) {\n    $wbwindow.__WB_replay_top = $wbwindow.top;\n    $wbwindow.__WB_top_frame = undefined;\n    this.replayTopHost = replay_top.location.host;\n    this.replayTopProtocol = replay_top.location.protocol;\n    return;\n  }\n\n  var next_parent = function(win) {\n    try {\n      if (!win) return false;\n      // if no wbinfo, see if _wb_wombat was set (eg. if about:blank page)\n      if (!win.wbinfo) {\n        return win._wb_wombat != null;\n      } else {\n        // otherwise, ensure that it is not a top container frame\n        return win.wbinfo.is_framed;\n      }\n    } catch (e) {\n      return false;\n    }\n  };\n\n  var replay_top = $wbwindow;\n  while (replay_top.parent != replay_top && next_parent(replay_top.parent)) {\n    replay_top = replay_top.parent;\n  }\n\n  $wbwindow.__WB_replay_top = replay_top;\n  this.replayTopHost = replay_top.location.host;\n  this.replayTopProtocol = replay_top.location.protocol;\n\n  var real_parent = replay_top.parent;\n  // Check to ensure top frame is different window and directly accessible (later refactor to support postMessage)\n  if (real_parent == $wbwindow || !this.wb_info.is_framed) {\n    real_parent = undefined;\n  }\n\n  if (real_parent) {\n    $wbwindow.__WB_top_frame = real_parent;\n    this.initFrameElementOverride($wbwindow);\n  } else {\n    $wbwindow.__WB_top_frame = undefined;\n  }\n\n  // if not top-replay frame and using auto-fetch workers, register listener\n  // messaging here\n  if (!this.wb_opts.embedded && replay_top == $wbwindow) {\n    if (this.wbUseAFWorker) {\n      var wombat = this;\n      this.$wbwindow.addEventListener(\n        'message',\n        function(event) {\n          if (\n            event.data &&\n            event.data.wb_type === 'aaworker' &&\n            wombat.WBAutoFetchWorker\n          ) {\n            wombat.WBAutoFetchWorker.postMessage(event.data.msg);\n          }\n        },\n        false\n      );\n    }\n    //removed to rely on proxy object override to ensure 'parent' and 'top' overridden together\n    //$wbwindow.__WB_orig_parent = $wbwindow.parent;\n    //$wbwindow.parent = replay_top;\n  }\n};\n\n/**\n * Applies an override to window.frameElement IFF the supplied windows\n * __WB_replay_top property is equal to the window object of the browser context\n * wombat is currently operating in\n * @param {Window} $wbwindow\n */\nWombat.prototype.initFrameElementOverride = function($wbwindow) {\n  if (!Object.defineProperty) return;\n  // Also try disabling frameElement directly, though may no longer be supported in all browsers\n  if (\n    this.proxyToObj($wbwindow.__WB_replay_top) == this.proxyToObj($wbwindow)\n  ) {\n    try {\n      Object.defineProperty($wbwindow, 'frameElement', {\n        value: null,\n        configurable: false\n      });\n    } catch (e) {}\n  }\n};\n\n/**\n * Adds the WB_wombat_top property to the prototype of Object\n * @param {Window} $wbwindow\n */\nWombat.prototype.initWombatTop = function($wbwindow) {\n  if (!Object.defineProperty) return;\n\n  // from http://stackoverflow.com/a/6229603\n  var isWindow = function isWindow(obj) {\n    if (typeof window.constructor === 'undefined') {\n      return obj instanceof window.constructor;\n    }\n    return obj.window == obj;\n  };\n\n  var getter = function top() {\n    if (this.__WB_replay_top) {\n      return this.__WB_replay_top;\n    } else if (isWindow(this)) {\n      return this;\n    }\n    return this.top;\n  };\n\n  var setter = function top(val) {\n    this.top = val;\n  };\n\n  this.defProp($wbwindow.Object.prototype, 'WB_wombat_top', setter, getter);\n};\n\n/**\n * To quote the MDN: 'Do not ever use eval'\n */\nWombat.prototype.initEvalOverride = function() {\n  var rewriteEvalArg = this.rewriteEvalArg;\n  var setNoop = function() {};\n\n  this.wrappedEval = function (evalFunc) {\n    return function(arg) {\n      return rewriteEvalArg(evalFunc, arg);\n    };\n  };\n\n  var wombat = this;\n\n  var runEval = function runEval(func) {\n    var obj = this;\n\n    if (obj && obj.eval && obj.eval !== eval) {\n      return {\n        eval: function() {\n          return obj.eval.__WB_orig_apply(obj, arguments);\n        }\n      };\n    } else {\n      return {\n        eval: function(arg) {\n          return rewriteEvalArg(func, arg);\n        }\n      };\n    }\n  };\n\n  // with additional global opt\n  var runEval2 = function runEval(func) {\n    var obj = this;\n\n    if (obj && obj.eval && obj.eval !== eval) {\n      return {\n        eval: function() {\n          // should have at least 2 arguments as 2 are injected\n          return obj.eval.__WB_orig_apply(obj, [].slice.call(arguments, 2));\n        }\n      };\n    } else {\n      return {\n        eval: function(thisObj, args, evalparam) {\n          // ensure this === window\n          var isGlobal = (thisObj === wombat.proxyToObj(wombat.$wbwindow));\n          // wrap in try/catch in the off chance case we're in strict mode, and then treat as non-global\n          try {\n            isGlobal = isGlobal && !args.callee.caller;\n          } catch (e) {\n            isGlobal = false;\n          }\n          return rewriteEvalArg(func, evalparam, isGlobal);\n        }\n      };\n    }\n  };\n\n  this.defProp(\n    this.$wbwindow.Object.prototype,\n    'WB_wombat_runEval',\n    setNoop,\n    function() {\n      return runEval;\n    }\n  );\n\n  // for extra global eval option\n  this.defProp(\n    this.$wbwindow.Object.prototype,\n    'WB_wombat_runEval2',\n    setNoop,\n    function() {\n      return runEval2;\n    }\n  );\n};\n\n/**\n * Initialize wombat's internal state and apply all overrides\n * @return {Object}\n */\nWombat.prototype.wombatInit = function() {\n  // wombat init\n  this._internalInit();\n\n  this.initCookiePreset();\n\n  // History\n  this.initHistoryOverrides();\n\n  this.overrideFunctionApply(this.$wbwindow);\n  this.overrideFunctionBind(this.$wbwindow);\n\n  // Doc Title\n  this.initDocTitleOverride();\n  this.initHashChange();\n\n  // postMessage\n  // OPT skip\n  if (!this.wb_opts.skip_postmessage) {\n    this.initPostMessageOverride(this.$wbwindow);\n    this.initMessageEventOverride(this.$wbwindow);\n  }\n\n  // proxy check this func\n  this.initCheckThisFunc(this.$wbwindow);\n\n\n  // add __wb_import__ for modules\n  this.initImportWrapperFunc(this.$wbwindow);\n\n  // override getOwnPropertyNames\n  this.overrideGetOwnPropertyNames(this.$wbwindow);\n\n\n  this.initUIEventsOverrides();\n\n  // write\n  this.initDocWriteOpenCloseOverride();\n\n  // eval\n  this.initEvalOverride();\n\n  // Ajax, Fetch, Request, Response, EventSource, WebSocket\n  this.initHTTPOverrides();\n\n  // Audio\n  this.initAudioOverride();\n\n  // FontFace\n  this.initFontFaceOverride(this.$wbwindow);\n\n  // Worker override (experimental)\n  this.initWorkerOverrides();\n\n  // text node overrides for js frameworks doing funky things with CSS\n  this.initTextNodeOverrides();\n  this.initCSSOMOverrides();\n\n  // innerHTML & outerHTML can be overridden on prototype!\n  // we must override innerHTML & outerHTML on Element otherwise un-rewritten HTML\n  // can get into replay\n  this.overrideHtmlAssign(this.$wbwindow.Element, 'innerHTML', true);\n  this.overrideHtmlAssign(this.$wbwindow.Element, 'outerHTML', true);\n  this.overrideHtmlAssignSrcDoc(this.$wbwindow.HTMLIFrameElement, 'srcdoc', true);\n  this.overrideHtmlAssign(this.$wbwindow.HTMLStyleElement, 'textContent');\n  this.overrideShadowDom();\n\n  // Document.URL override\n  this.overridePropExtract(this.$wbwindow.Document.prototype, 'URL');\n  this.overridePropExtract(this.$wbwindow.Document.prototype, 'documentURI');\n\n  // Node.baseURI override\n  this.overridePropExtract(this.$wbwindow.Node.prototype, 'baseURI');\n\n  // Attr nodeValue and value\n  this.overrideAttrProps();\n\n  // Override dataset access and wrap in proxy\n  this.overrideDataSet();\n\n  // init insertAdjacent[Element, HTML] override\n  this.initInsertAdjacentElementHTMLOverrides();\n\n  // iframe.contentWindow and iframe.contentDocument overrides to\n  // ensure _wombat is inited on the iframe $wbwindow!\n  this.overrideIframeContentAccess('contentWindow');\n  this.overrideIframeContentAccess('contentDocument');\n\n  // override funcs to convert first arg proxy->obj\n  this.overrideFuncArgProxyToObj(this.$wbwindow.MutationObserver, 'observe');\n  this.overrideFuncArgProxyToObj(\n    this.$wbwindow.Node,\n    'compareDocumentPosition'\n  );\n  this.overrideFuncArgProxyToObj(this.$wbwindow.Node, 'contains');\n  this.overrideFuncArgProxyToObj(this.$wbwindow.Document, 'createTreeWalker');\n  this.overrideFuncArgProxyToObj(this.$wbwindow.Document, 'evaluate', 1);\n  this.overrideFuncArgProxyToObj(\n    this.$wbwindow.XSLTProcessor,\n    'transformToFragment',\n    1\n  );\n\n  this.overrideFuncThisProxyToObj(\n    this.$wbwindow,\n    'getComputedStyle',\n    this.$wbwindow\n  );\n\n  this.overrideFuncThisProxyToObj(this.$wbwindow, 'clearTimeout');\n  this.overrideFuncThisProxyToObj(this.$wbwindow, 'clearInterval');\n\n  this.overrideFuncThisProxyToObj(\n    this.$wbwindow.EventTarget.prototype,\n    'dispatchEvent'\n  );\n\n  this.initTimeoutIntervalOverrides();\n\n  this.overrideFramesAccess(this.$wbwindow);\n\n  this.overrideSWAccess(this.$wbwindow);\n\n  // setAttribute\n  this.initElementGetSetAttributeOverride();\n\n  this.initSvgImageOverrides();\n\n  // override href and src attrs\n  this.initAttrOverrides();\n\n  // Cookies\n  this.initCookiesOverride();\n\n  // ensure namespace urls are NOT rewritten\n  this.initCreateElementNSFix();\n\n  // DOM\n  // OPT skip\n  if (!this.wb_opts.skip_dom) {\n    this.initDomOverride();\n  }\n\n  // registerProtocolHandler override\n  this.initRegisterUnRegPHOverride();\n  this.initPresentationRequestOverride();\n\n  // sendBeacon override\n  this.initBeaconOverride();\n\n  // additional navigator. overrides\n  this.initMiscNavigatorOverrides();\n\n  // other overrides\n  // proxy mode: only using these overrides\n\n  // Random\n  this.initSeededRandom(this.wb_info.wombat_sec);\n\n  // Crypto Random\n  this.initCryptoRandom();\n\n  // set fixed pixel ratio\n  this.initFixedRatio(this.wb_info.pixel_ratio || 1);\n\n  // Date\n  this.initDateOverride(this.wb_info.wombat_sec);\n\n  // Blob\n  this.initBlobOverride();\n\n  // WebSocket\n  this.initWSOverride();\n\n  // open\n  this.initOpenOverride();\n\n  // disable notifications\n  this.initDisableNotificationsGeoLocation();\n\n  // custom storage\n  this.initStorageOverride();\n\n  // wrap caches to ensure only host sandboxed caches are available\n  this.initCachesOverride();\n\n  // wraps indexeddb access to ensure only host sandboxed dbs are available\n  this.initIndexedDBOverride();\n\n  // add window and document obj proxies, if available\n  this.initWindowObjProxy(this.$wbwindow);\n  this.initDocumentObjProxy(this.$wbwindow.document);\n\n  var wombat = this;\n  return {\n    extract_orig: this.extractOriginalURL,\n    rewrite_url: this.rewriteUrl,\n    watch_elem: this.watchElem,\n    init_new_window_wombat: this.initNewWindowWombat,\n    init_paths: this.initPaths,\n    local_init: function(name) {\n      var res = wombat.$wbwindow._WB_wombat_obj_proxy[name];\n      if (name === 'document' && res && !res._WB_wombat_obj_proxy) {\n        return wombat.initDocumentObjProxy(res) || res;\n      }\n      return res;\n    },\n    showCSPViolations: function(yesNo) {\n      wombat._addRemoveCSPViolationListener(yesNo);\n    }\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Wombat);\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/wombat.js?")},"../wombat/src/wombatLocation.js":
/*!***************************************!*\
  !*** ../wombat/src/wombatLocation.js ***!
  \***************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WombatLocation)\n/* harmony export */ });\n/* harmony import */ var _wombatUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wombatUtils */ \"../wombat/src/wombatUtils.js\");\n/* eslint-disable camelcase */\n\n\n/**\n * A re-implementation of the Location interface that ensure that operations\n * on the location interface behaves as expected during replay.\n * @param {Location} orig_loc\n * @param {Wombat} wombat\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Location\n * @see https://html.spec.whatwg.org/multipage/browsers.html#the-location-interface\n */\nfunction WombatLocation(orig_loc, wombat) {\n  // hide our values from enumeration, spreed, et al\n  Object.defineProperties(this, {\n    _orig_loc: {\n      configurable: true,\n      enumerable: false,\n      value: orig_loc\n    },\n    wombat: {\n      configurable: true,\n      enumerable: false,\n      value: wombat\n    },\n    orig_getter: {\n      enumerable: false,\n      value: function(prop) {\n        return this._orig_loc[prop];\n      }\n    },\n    orig_setter: {\n      enumerable: false,\n      value: function(prop, value) {\n        if (this._orig_loc[prop] != value) {\n          this._orig_loc[prop] = value;\n        }\n      }\n    }\n  });\n\n  wombat.initLocOverride(this, this.orig_setter, this.orig_getter);\n\n  wombat.setLoc(this, orig_loc.href);\n\n  for (var prop in orig_loc) {\n    if (!this.hasOwnProperty(prop) && typeof orig_loc[prop] !== 'function') {\n      this[prop] = orig_loc[prop];\n    }\n  }\n}\n\n/**\n * Replaces the current resource with the one at the provided URL.\n * The difference from the assign() method is that after using replace() the\n * current page will not be saved in session History, meaning the user won't\n * be able to use the back button to navigate to it.\n * @param {string} url\n * @return {*}\n */\nWombatLocation.prototype.replace = function replace(url) {\n  var new_url = this.wombat.rewriteUrl(url);\n  var orig = this.wombat.extractOriginalURL(new_url);\n  if (orig === this.href) {\n    return orig;\n  }\n  return this._orig_loc.replace(new_url);\n};\n\n/**\n * Loads the resource at the URL provided in parameter\n * @param {string} url\n * @return {*}\n */\nWombatLocation.prototype.assign = function assign(url) {\n  var new_url = this.wombat.rewriteUrl(url);\n  var orig = this.wombat.extractOriginalURL(new_url);\n  if (orig === this.href) {\n    return orig;\n  }\n  return this._orig_loc.assign(new_url);\n};\n\n/**\n * Reloads the resource from the current URL. Its optional unique parameter\n * is a Boolean, which, when it is true, causes the page to always be reloaded\n * from the server. If it is false or not specified, the browser may reload\n * the page from its cache.\n * @param {boolean} [forcedReload = false]\n * @return {*}\n */\nWombatLocation.prototype.reload = function reload(forcedReload) {\n  //return this._orig_loc.reload(forcedReload || false);\n  return;\n};\n\n/**\n * @return {string}\n */\nWombatLocation.prototype.toString = function toString() {\n  return this.href;\n};\n\n/**\n * @return {WombatLocation}\n */\nWombatLocation.prototype.valueOf = function valueOf() {\n  return this;\n};\n\n(0,_wombatUtils__WEBPACK_IMPORTED_MODULE_0__.addToStringTagToClass)(WombatLocation, 'Location');\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/wombatLocation.js?")},"../wombat/src/wombatUtils.js":
/*!************************************!*\
  !*** ../wombat/src/wombatUtils.js ***!
  \************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThrowExceptions\": () => (/* binding */ ThrowExceptions),\n/* harmony export */   \"addToStringTagToClass\": () => (/* binding */ addToStringTagToClass),\n/* harmony export */   \"autobind\": () => (/* binding */ autobind),\n/* harmony export */   \"ensureNumber\": () => (/* binding */ ensureNumber)\n/* harmony export */ });\n/**\n * Ensures the supplied argument is a number or if it is not (can not be coerced to a number)\n * this function returns null.\n * @param {*} maybeNumber\n * @return {?number}\n */\nfunction ensureNumber(maybeNumber) {\n  try {\n    switch (typeof maybeNumber) {\n      case 'number':\n      case 'bigint':\n        return maybeNumber;\n    }\n    var converted = Number(maybeNumber);\n    return !isNaN(converted) ? converted : null;\n  } catch (e) {}\n  return null;\n}\n\n/**\n * Sets the supplied object's toStringTag IFF\n * self.Symbol && self.Symbol.toStringTag are defined\n * @param {Object} clazz\n * @param {string} tag\n */\nfunction addToStringTagToClass(clazz, tag) {\n  if (\n    typeof self.Symbol !== 'undefined' &&\n    typeof self.Symbol.toStringTag !== 'undefined'\n  ) {\n    Object.defineProperty(clazz.prototype, self.Symbol.toStringTag, {\n      value: tag,\n      enumerable: false\n    });\n  }\n}\n\n/**\n * Binds every function this, except the constructor, of the supplied object\n * to the instance of the supplied object\n * @param {Object} clazz\n */\nfunction autobind(clazz) {\n  var proto = clazz.__proto__ || clazz.constructor.prototype || clazz.prototype;\n  var clazzProps = Object.getOwnPropertyNames(proto);\n  var len = clazzProps.length;\n  var prop;\n  var propValue;\n  for (var i = 0; i < len; i++) {\n    prop = clazzProps[i];\n    propValue = clazz[prop];\n    if (prop !== 'constructor' && typeof propValue === 'function') {\n      clazz[prop] = propValue.bind(clazz);\n    }\n  }\n}\n\n/**\n * Because we overriding specific interfaces (e.g. Storage) that do not expose\n * an constructor only an interface object with our own we must have a way\n * to indicate to our overrides when it is proper to throw exceptions\n * @type {{yes: boolean}}\n */\nvar ThrowExceptions = { yes: false };\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/src/wombatUtils.js?")},"../wombat/node_modules/warcio/dist/utils.js":
/*!***************************************************!*\
  !*** ../wombat/node_modules/warcio/dist/utils.js ***!
  \***************************************************/(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "appendRequestQuery": () => (/* binding */ f),\n/* harmony export */   "concatChunks": () => (/* binding */ x),\n/* harmony export */   "getSurt": () => (/* binding */ d),\n/* harmony export */   "jsonToQueryParams": () => (/* binding */ p),\n/* harmony export */   "jsonToQueryString": () => (/* binding */ c),\n/* harmony export */   "mfdToQueryParams": () => (/* binding */ y),\n/* harmony export */   "mfdToQueryString": () => (/* binding */ g),\n/* harmony export */   "postToGetUrl": () => (/* binding */ w),\n/* harmony export */   "splitChunk": () => (/* binding */ U)\n/* harmony export */ });\nfunction u(t){let e;typeof t=="string"?e=t:t&&t.length?e=t.reduce((r,n)=>(r+=String.fromCharCode(n),r),""):t?e=t.toString():e="";try{return"__wb_post_data="+btoa(e)}catch{return"__wb_post_data="}}function m(t){return t.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&")}function d(t){try{if(!t.startsWith("https:")&&!t.startsWith("http:"))return t;t=t.replace(/^(https?:\\/\\/)www\\d*\\./,"$1");let e=t.toLowerCase(),r=new URL(e),i=r.hostname.split(".").reverse().join(",");if(r.port&&(i+=":"+r.port),i+=")",i+=r.pathname,r.search){r.searchParams.sort(),i+=r.search;for(let[o,s]of r.searchParams.entries())if(!s){let a=new RegExp(`(?<=[&?])${m(o)}=(?=&|$)`);a.exec(e)||(i=i.replace(a,o))}}return i}catch{return t}}function w(t){let{method:e,headers:r,postData:n}=t;if(e==="GET")return!1;let i=(r.get("content-type")||"").split(";")[0];function o(a){return a instanceof Uint8Array&&(a=new TextDecoder().decode(a)),a}let s="";switch(i){case"application/x-www-form-urlencoded":s=o(n);break;case"application/json":s=c(o(n));break;case"text/plain":try{s=c(o(n),!1)}catch{s=u(n)}break;case"multipart/form-data":{let a=r.get("content-type");if(!a)throw new Error("utils cannot call postToGetURL when missing content-type header");s=g(o(n),a);break}default:s=u(n)}return s!==null?(t.url=f(t.url,s,t.method),t.method="GET",t.requestBody=s,!0):!1}function f(t,e,r){if(!r)return t;let n=t.indexOf("?")>0?"&":"?";return`${t}${n}__wb_method=${r}&${e}`}function p(t,e=!0){if(typeof t=="string")try{t=JSON.parse(t)}catch{t={}}let r=new URLSearchParams,n={},i=o=>r.has(o)?(o in n||(n[o]=1),o+"."+ ++n[o]+"_"):o;try{JSON.stringify(t,(o,s)=>(["object","function"].includes(typeof s)||r.set(i(o),s),s))}catch(o){if(!e)throw o}return r}function y(t,e){let r=new URLSearchParams;t instanceof Uint8Array&&(t=new TextDecoder().decode(t));try{let n=e.split("boundary=")[1],i=t.split(new RegExp("-*"+n+"-*","mi"));for(let o of i){let s=o.trim().match(/name="([^"]+)"\\r\\n\\r\\n(.*)/im);s&&r.set(s[1],s[2])}}catch{}return r}function c(t,e=!0){return p(t,e).toString()}function g(t,e){return y(t,e).toString()}function x(t,e){if(t.length===1)return t[0];let r=new Uint8Array(e),n=0;for(let i of t)r.set(i,n),n+=i.byteLength;return r}function U(t,e){return[t.slice(0,e),t.slice(e)]}\n\n\n//# sourceURL=webpack://@webrecorder/wabac/../wombat/node_modules/warcio/dist/utils.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("../wombat/src/wbWombat.js")})();