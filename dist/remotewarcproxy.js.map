{"version":3,"file":"remotewarcproxy.js","sourceRoot":"","sources":["../src/remotewarcproxy.ts"],"names":[],"mappings":"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","sourcesContent":["import { ArchiveResponse } from \"./response\";\nimport { fuzzyMatcher } from \"./fuzzymatcher\";\n\nimport { WARCParser, AsyncIterReader, type Source } from \"warcio\";\nimport { type DBStore } from \"./types\";\nimport { type ArchiveRequest } from \"./request\";\n\n// ===========================================================================\nexport class RemoteWARCProxy implements DBStore {\n  sourceUrl: string;\n  type: string;\n  notFoundPageUrl: string;\n\n  // [TODO]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(rootConfig: Record<string, any>) {\n    // @ts-expect-error [TODO] - TS4111 - Property 'extraConfig' comes from an index signature, so it must be accessed with ['extraConfig'].\n    const config = rootConfig.extraConfig || {};\n\n    this.sourceUrl = config.prefix;\n    this.type = config.sourceType || \"kiwix\";\n    this.notFoundPageUrl = config.notFoundPageUrl;\n  }\n\n  async getAllPages() {\n    return [];\n  }\n\n  async getResource(\n    request: ArchiveRequest,\n    prefix: string,\n  ): Promise<ArchiveResponse | Response | null> {\n    const { url, headers } = request.prepareProxyRequest(prefix);\n    let reqHeaders: HeadersInit = headers;\n\n    if (this.type === \"kiwix\") {\n      let headersData = await this.resolveHeaders(url);\n\n      if (!headersData) {\n        for (const newUrl of fuzzyMatcher.getFuzzyCanonsWithArgs(url)) {\n          if (newUrl !== url) {\n            headersData = await this.resolveHeaders(newUrl);\n            if (headersData) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (!headersData) {\n        // use custom error page for navigate events\n        if (this.notFoundPageUrl && request.mode === \"navigate\") {\n          const resp = await fetch(this.notFoundPageUrl);\n          // load 'not found' page template\n          if (resp.status === 200) {\n            const headers = { \"Content-Type\": \"text/html\" };\n            const text = await resp.text();\n            return new Response(text.replace(\"$URL\", url), {\n              status: 404,\n              headers,\n            });\n          }\n        }\n\n        return null;\n      }\n\n      // [TODO]\n      // eslint-disable-next-line prefer-const\n      let { headers, encodedUrl, date, status, statusText, hasPayload } =\n        headersData;\n\n      if (reqHeaders.has(\"Range\")) {\n        const range = reqHeaders.get(\"Range\");\n        // ensure uppercase range to avoid bug in kiwix-serve\n        if (range) {\n          reqHeaders = { Range: range };\n        }\n      }\n\n      let payload: AsyncIterReader | Uint8Array | null = null;\n\n      let response: Response | null = null;\n\n      if (!headers) {\n        headers = new Headers();\n      }\n\n      if (hasPayload) {\n        response = await fetch(this.sourceUrl + \"A/\" + encodedUrl, {\n          headers: reqHeaders,\n        });\n\n        if (response.body) {\n          payload = new AsyncIterReader(response.body.getReader(), null, false);\n        }\n\n        if (response.status === 206) {\n          const CL = response.headers.get(\"Content-Length\");\n          const CR = response.headers.get(\"Content-Range\");\n          if (CL && CR) {\n            status = 206;\n            statusText = \"Partial Content\";\n            headers.set(\"Content-Length\", CL);\n            headers.set(\"Content-Range\", CR);\n            headers.set(\"Accept-Ranges\", \"bytes\");\n          }\n        }\n      }\n\n      if (!payload) {\n        payload = new Uint8Array([]);\n      }\n\n      if (!date) {\n        date = new Date();\n      }\n\n      const isLive = false;\n      const noRW = false;\n\n      return new ArchiveResponse({\n        payload,\n        status,\n        statusText,\n        headers,\n        url,\n        date,\n        noRW,\n        isLive,\n      });\n    }\n\n    return null;\n  }\n\n  async resolveHeaders(url: string): Promise<{\n    encodedUrl: string;\n    headers: Headers | null;\n    date: Date | null;\n    status: number;\n    statusText: string;\n    hasPayload: boolean;\n  } | null> {\n    const urlNoScheme = url.slice(url.indexOf(\"//\") + 2);\n\n    // need to escape utf-8, then % encode the entire string\n    let encodedUrl = encodeURI(urlNoScheme);\n    encodedUrl = encodeURIComponent(urlNoScheme);\n\n    const headersResp = await fetch(this.sourceUrl + \"H/\" + encodedUrl);\n\n    if (headersResp.status !== 200) {\n      return null;\n    }\n\n    let headers: Headers | null = null;\n    let date: Date | null = null;\n    let status = 200;\n    let statusText = \"OK\";\n    let hasPayload = false;\n\n    try {\n      const record = await WARCParser.parse(headersResp.body as Source);\n\n      if (!record) {\n        return null;\n      }\n\n      if (record.warcType === \"revisit\") {\n        const warcRevisitTarget = record.warcHeaders.headers.get(\n          \"WARC-Refers-To-Target-URI\",\n        );\n        if (warcRevisitTarget && warcRevisitTarget !== url) {\n          return await this.resolveHeaders(warcRevisitTarget);\n        }\n      }\n\n      date = new Date(record.warcDate!);\n\n      if (record.httpHeaders) {\n        headers = record.httpHeaders.headers as Headers;\n        status = Number(record.httpHeaders.statusCode);\n        statusText = record.httpHeaders.statusText || \"\";\n        hasPayload = record.httpHeaders.headers.get(\"Content-Length\") !== \"0\";\n      } else if (record.warcType === \"resource\") {\n        headers = new Headers();\n        headers.set(\"Content-Type\", record.warcContentType || \"\");\n        headers.set(\"Content-Length\", record.warcContentLength + \"\");\n        status = 200;\n        statusText = \"OK\";\n        hasPayload = record.warcContentLength > 0;\n      }\n\n      if (!status) {\n        status = 200;\n      }\n    } catch (e) {\n      console.warn(e);\n      console.warn(\n        \"Ignoring headers, error parsing headers response for: \" + url,\n      );\n    }\n\n    return { encodedUrl, headers, date, status, statusText, hasPayload };\n  }\n}\n"]}