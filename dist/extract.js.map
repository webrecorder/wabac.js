{"version":3,"file":"extract.js","sourceRoot":"","sources":["../src/extract.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAE9C,OAAO,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAElD,MAAM,YAAY,GAAG;IACnB,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,YAAY;IACZ,UAAU;CACX,CAAC;AAEF,8EAA8E;AAC9E,KAAK,UAAU,WAAW,CACxB,GAAW,EACX,MAAkB,EAClB,EAAiB,EACjB,EAAiB;IAEjB,MAAM,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;IAC/B,MAAM,UAAU,GAAa,EAAE,CAAC;IAChC,IAAI,OAAO,GAAkB,IAAI,CAAC;IAElC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE;QACnC,IAAI,OAAO,EAAE,CAAC;YACZ,OAAO;QACT,CAAC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;QAC9B,IAAI,IAAI,EAAE,CAAC;YACT,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,QAAQ,EAAE,EAAE;QACjC,IAAI,CAAC,QAAQ,CAAC,WAAW,IAAI,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;YACrE,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;QAC7B,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,MAAM,EAAE,EAAE;QAC7B,IAAI,MAAM,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;YAC/B,OAAO,GAAG,IAAI,CAAC;QACjB,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC;QACb,MAAM,GAAG,MAAM,aAAa,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,CAAC;IAED,MAAM,CAAC,GAAG,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAE7C,MAAM,CAAC,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAChC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YACpB,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC,CAAC;AACjB,CAAC;AAED,OAAO,EAAE,WAAW,EAAE,CAAC","sourcesContent":["import { SAXParser } from \"parse5-sax-parser\";\n\nimport { decodeContent } from \"./rewrite/decoder\";\n\nconst SKIPPED_TAGS = [\n  \"script\",\n  \"style\",\n  \"header\",\n  \"footer\",\n  \"banner-div\",\n  \"noscript\",\n];\n\n// ===========================================================================\nasync function extractText(\n  url: string,\n  buffer: Uint8Array,\n  ce: string | null,\n  te: string | null,\n) {\n  const parser = new SAXParser();\n  const textChunks: string[] = [];\n  let context: string | null = null;\n\n  parser.on(\"text\", (data /*, raw*/) => {\n    if (context) {\n      return;\n    }\n    const text = data.text.trim();\n    if (text) {\n      textChunks.push(text);\n    }\n  });\n\n  parser.on(\"startTag\", (startTag) => {\n    if (!startTag.selfClosing && SKIPPED_TAGS.includes(startTag.tagName)) {\n      context = startTag.tagName;\n    }\n  });\n\n  parser.on(\"endTag\", (endTag) => {\n    if (endTag.tagName === context) {\n      context = null;\n    }\n  });\n\n  if (ce || te) {\n    buffer = await decodeContent(buffer, ce, te);\n  }\n\n  parser.end(new TextDecoder().decode(buffer));\n\n  const p = new Promise((resolve) => {\n    parser.on(\"end\", () => {\n      resolve(textChunks.join(\" \"));\n    });\n  });\n\n  return await p;\n}\n\nexport { extractText };\n"]}